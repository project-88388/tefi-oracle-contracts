"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readSchemas = exports.findResponses = exports.findQueryMsg = exports.findExecuteMsg = exports.findAndParseTypes = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _glob = require("glob");

var _fs = require("fs");

var _cleanse = require("./cleanse");

var _jsonSchemaToTypescript = require("json-schema-to-typescript");

var _parse = require("./parse");

var readSchemas = function readSchemas(_ref) {
  var schemaDir = _ref.schemaDir,
      argv = _ref.argv,
      _ref$clean = _ref.clean,
      clean = _ref$clean === void 0 ? true : _ref$clean;
  var fn = clean ? _cleanse.cleanse : function (str) {
    return str;
  };
  var files = (0, _glob.sync)(schemaDir + '/**/*.json');
  var schemas = files.map(function (file) {
    return JSON.parse((0, _fs.readFileSync)(file, 'utf-8'));
  });

  if (argv.packed) {
    if (schemas.length !== 1) {
      throw new Error('packed option only supports one file');
    }

    return Object.values(fn(schemas[0]));
  }

  return fn(schemas);
};

exports.readSchemas = readSchemas;

var findQueryMsg = function findQueryMsg(schemas) {
  var QueryMsg = schemas.find(function (schema) {
    return schema.title === 'QueryMsg';
  });
  return QueryMsg;
};

exports.findQueryMsg = findQueryMsg;

var findResponses = function findResponses(schemas) {
  return schemas.filter(function (schema) {
    return schema.title.includes('Response');
  }).map(function (i) {
    return i.title;
  });
};

exports.findResponses = findResponses;

var findExecuteMsg = function findExecuteMsg(schemas) {
  var ExecuteMsg = schemas.find(function (schema) {
    return schema.title === 'ExecuteMsg' || schema.title === 'ExecuteMsg_for_Empty' || // if cleanse is used, this is never
    schema.title === 'ExecuteMsgForEmpty';
  });
  return ExecuteMsg;
};

exports.findExecuteMsg = findExecuteMsg;

var findAndParseTypes = /*#__PURE__*/function () {
  var _ref2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(schemas) {
    var Types, allTypes, typ, _i, _Object$keys, key, result, typeHash;

    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            Types = schemas;
            allTypes = [];
            _context.t0 = _regenerator["default"].keys(Types);

          case 3:
            if ((_context.t1 = _context.t0()).done) {
              _context.next = 12;
              break;
            }

            typ = _context.t1.value;

            if (Types[typ].definitions) {
              for (_i = 0, _Object$keys = Object.keys(Types[typ].definitions); _i < _Object$keys.length; _i++) {
                key = _Object$keys[_i];
                // set title
                Types[typ].definitions[key].title = key;
              }
            }

            _context.next = 8;
            return (0, _jsonSchemaToTypescript.compile)(Types[typ], Types[typ].title);

          case 8:
            result = _context.sent;
            allTypes.push(result);
            _context.next = 3;
            break;

          case 12:
            typeHash = (0, _parse.parser)(allTypes);
            return _context.abrupt("return", typeHash);

          case 14:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function findAndParseTypes(_x) {
    return _ref2.apply(this, arguments);
  };
}();

exports.findAndParseTypes = findAndParseTypes;