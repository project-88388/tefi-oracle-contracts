"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createWasmQueryMethod = exports.createWasmExecMethod = exports.createTypeOrInterface = exports.createTypeInterface = exports.createQueryInterface = exports.createQueryClass = exports.createPropertyFunctionWithObjectParamsForExec = exports.createPropertyFunctionWithObjectParams = exports.createExecuteInterface = exports.createExecuteClass = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var t = _interopRequireWildcard(require("@babel/types"));

var _case = require("case");

var _utils = require("./utils");

var _types2 = require("./utils/types");

var _babel = require("./utils/babel");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var createWasmQueryMethod = function createWasmQueryMethod(jsonschema, responses) {
  var _jsonschema$propertie;

  var underscoreName = Object.keys(jsonschema.properties)[0];
  var methodName = (0, _case.camel)(underscoreName);
  var responseType = (0, _case.pascal)("".concat(methodName, "Response")); // Support naming query responses exactly like the method, or without a preceding "Get".

  if (!responses.includes(responseType)) {
    var modifiedMethodName = methodName.replace('get', '');
    responseType = (0, _case.pascal)("".concat(modifiedMethodName, "Response"));
  }

  var properties = (_jsonschema$propertie = jsonschema.properties[underscoreName].properties) !== null && _jsonschema$propertie !== void 0 ? _jsonschema$propertie : {};
  var obj = (0, _types2.createTypedObjectParams)(jsonschema.properties[underscoreName]);
  var args = Object.keys(properties).map(function (prop) {
    return t.objectProperty(t.identifier(prop), t.identifier((0, _case.camel)(prop)), false, true);
  });
  var actionArg = t.objectProperty(t.identifier(underscoreName), t.objectExpression(args));
  return t.classProperty(t.identifier((0, _utils.convertToQueryMethod)(methodName)), (0, _utils.arrowFunctionExpression)(obj ? [obj] : [], t.blockStatement([t.returnStatement(t.callExpression(t.memberExpression(t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier("client")), t.identifier("wasm")), t.identifier("contractQuery")), [t.memberExpression(t.thisExpression(), t.identifier("contractAddress")), t.objectExpression([actionArg])]))]), t.tsTypeAnnotation(t.tsTypeReference(t.identifier("Promise"), t.tsTypeParameterInstantiation([t.tSTypeReference(t.identifier(responseType))]))), true));
};

exports.createWasmQueryMethod = createWasmQueryMethod;

var createQueryClass = function createQueryClass(className, implementsClassName, queryMsg, responses) {
  var propertyNames = (0, _utils.getMessageProperties)(queryMsg).map(function (method) {
    var _Object$keys;

    return (_Object$keys = Object.keys(method.properties)) === null || _Object$keys === void 0 ? void 0 : _Object$keys[0];
  }).filter(Boolean);
  var bindings = propertyNames.map(_case.camel).map(_utils.convertToQueryMethod).map(_utils.bindMethod);
  var methods = (0, _utils.getMessageProperties)(queryMsg).map(function (schema) {
    return createWasmQueryMethod(schema, responses);
  });
  return t.exportNamedDeclaration((0, _utils.classDeclaration)(className, [// client
  (0, _utils.classProperty)("client", t.tsTypeAnnotation(t.tsTypeReference(t.identifier("LCDClient")))), // contractAddress
  (0, _utils.classProperty)("contractAddress", t.tsTypeAnnotation(t.tsStringKeyword())), // constructor
  t.classMethod("constructor", t.identifier("constructor"), [(0, _utils.typedIdentifier)("client", t.tsTypeAnnotation(t.tsTypeReference(t.identifier("LCDClient")))), (0, _utils.typedIdentifier)("contractAddress", t.tsTypeAnnotation(t.tsStringKeyword()))], t.blockStatement([// client/contract set
  t.expressionStatement(t.assignmentExpression("=", t.memberExpression(t.thisExpression(), t.identifier("client")), t.identifier("client"))), t.expressionStatement(t.assignmentExpression("=", t.memberExpression(t.thisExpression(), t.identifier("contractAddress")), t.identifier("contractAddress")))].concat((0, _toConsumableArray2["default"])(bindings))))].concat((0, _toConsumableArray2["default"])(methods)), [t.tSExpressionWithTypeArguments(t.identifier(implementsClassName))]));
};

exports.createQueryClass = createQueryClass;

var createWasmExecMethod = function createWasmExecMethod(jsonschema) {
  var _jsonschema$propertie2;

  var underscoreName = Object.keys(jsonschema.properties)[0];
  var methodName = (0, _case.camel)(underscoreName);
  var properties = (_jsonschema$propertie2 = jsonschema.properties[underscoreName].properties) !== null && _jsonschema$propertie2 !== void 0 ? _jsonschema$propertie2 : {};
  var obj = (0, _types2.createTypedObjectParams)(jsonschema.properties[underscoreName]);
  var args = Object.keys(properties).map(function (prop) {
    return t.objectProperty(t.identifier(prop), t.identifier((0, _case.camel)(prop)), false, prop === (0, _case.camel)(prop));
  });
  var constantParams = [(0, _babel.identifier)("funds", t.tsTypeAnnotation(t.tsTypeReference(t.identifier("Coins"))), true)];
  return t.classProperty(t.identifier(methodName), (0, _utils.arrowFunctionExpression)(obj ? [// props
  obj].concat(constantParams) : constantParams, t.blockStatement([t.variableDeclaration("const", [t.variableDeclarator(t.identifier("senderAddress"), // TODO: Convert to t.conditionalExpression
  t.identifier("isConnectedWallet(this.wallet) ? this.wallet.walletAddress : this.wallet.key.accAddress"))]), t.variableDeclaration("const", [t.variableDeclarator(t.identifier("execMsg"), t.newExpression(t.identifier("MsgExecuteContract"), [t.identifier("senderAddress"), t.memberExpression(t.thisExpression(), t.identifier("contractAddress")), t.objectExpression([t.objectProperty(t.identifier(underscoreName), t.objectExpression((0, _toConsumableArray2["default"])(args)))]), t.identifier("funds")]))]), t.ifStatement(t.callExpression(t.identifier("isConnectedWallet"), [t.memberExpression(t.thisExpression(), t.identifier("wallet"))]), t.blockStatement([t.variableDeclaration("const", [t.variableDeclarator(t.identifier("tx"), t.awaitExpression(t.callExpression(t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier("wallet")), t.identifier("post")), [t.objectExpression([t.objectProperty(t.identifier("msgs"), t.arrayExpression([t.identifier("execMsg")]))])])))]), t.returnStatement(t.callExpression(t.identifier("waitForInclusionInBlock"), [t.memberExpression(t.thisExpression(), t.identifier("client")), t.memberExpression(t.memberExpression(t.identifier("tx"), t.identifier("result")), t.identifier("txhash"))]))]), t.blockStatement([t.variableDeclaration("const", [t.variableDeclarator(t.identifier("execTx"), t.awaitExpression(t.callExpression(t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier("wallet")), t.identifier("createAndSignTx")), [t.objectExpression([t.objectProperty(t.identifier("msgs"), t.arrayExpression([t.identifier("execMsg")]))])])))]), t.returnStatement(t.callExpression(t.memberExpression(t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier("client")), t.identifier("tx")), t.identifier("broadcast")), [t.identifier("execTx")]))]))]), // return type
  t.tsTypeAnnotation(t.tsTypeReference(t.identifier("Promise"), t.tsTypeParameterInstantiation([t.tsUnionType([t.tsTypeReference(t.identifier("WaitTxBroadcastResult")), t.tsTypeReference(t.identifier("TxInfo")), t.tsTypeReference(t.identifier("undefined"))])]))), true));
};

exports.createWasmExecMethod = createWasmExecMethod;

var createExecuteClass = function createExecuteClass(className, implementsClassName, extendsClassName, execMsg) {
  var propertyNames = (0, _utils.getMessageProperties)(execMsg).map(function (method) {
    var _Object$keys2;

    return (_Object$keys2 = Object.keys(method.properties)) === null || _Object$keys2 === void 0 ? void 0 : _Object$keys2[0];
  }).filter(Boolean);
  var bindings = propertyNames.map(_case.camel).map(_utils.bindMethod);
  var methods = (0, _utils.getMessageProperties)(execMsg).map(function (schema) {
    return createWasmExecMethod(schema);
  });
  var blockStmt = [];

  if (extendsClassName) {
    blockStmt.push( // super()
    t.expressionStatement(t.callExpression(t["super"](), [t.identifier("client"), t.identifier("contractAddress")])));
  }

  [].push.apply(blockStmt, [// client/contract set
  t.expressionStatement(t.assignmentExpression("=", t.memberExpression(t.thisExpression(), t.identifier("client")), t.identifier("client"))), t.expressionStatement(t.assignmentExpression("=", t.memberExpression(t.thisExpression(), t.identifier("wallet")), t.identifier("wallet"))), t.expressionStatement(t.assignmentExpression("=", t.memberExpression(t.thisExpression(), t.identifier("contractAddress")), t.identifier("contractAddress")))].concat((0, _toConsumableArray2["default"])(bindings)));
  return t.exportNamedDeclaration((0, _utils.classDeclaration)(className, [// client
  (0, _utils.classProperty)("client", t.tsTypeAnnotation(t.tsTypeReference(t.identifier("LCDClient")))), // wallet
  (0, _utils.classProperty)("wallet", t.tsTypeAnnotation(t.tsUnionType([t.tsTypeReference(t.identifier("Wallet")), t.tsTypeReference(t.identifier("ConnectedWallet"))]))), // contractAddress
  (0, _utils.classProperty)("contractAddress", t.tsTypeAnnotation(t.tsStringKeyword())), // constructor
  t.classMethod("constructor", t.identifier("constructor"), [(0, _utils.typedIdentifier)("client", t.tsTypeAnnotation(t.tsTypeReference(t.identifier("LCDClient")))), (0, _utils.typedIdentifier)("wallet", t.tsTypeAnnotation(t.tsUnionType([t.tsTypeReference(t.identifier("Wallet")), t.tsTypeReference(t.identifier("ConnectedWallet"))]))), (0, _utils.typedIdentifier)("contractAddress", t.tsTypeAnnotation(t.tsStringKeyword()))], t.blockStatement(blockStmt))].concat((0, _toConsumableArray2["default"])(methods)), [t.tSExpressionWithTypeArguments(t.identifier(implementsClassName))], extendsClassName ? t.identifier(extendsClassName) : null));
};

exports.createExecuteClass = createExecuteClass;

var createExecuteInterface = function createExecuteInterface(className, extendsClassName, execMsg) {
  var methods = (0, _utils.getMessageProperties)(execMsg).map(function (jsonschema) {
    var underscoreName = Object.keys(jsonschema.properties)[0];
    var methodName = (0, _case.camel)(underscoreName);
    return createPropertyFunctionWithObjectParamsForExec(methodName, // TODO: Set correct return.
    "any", jsonschema.properties[underscoreName]);
  });
  var extendsAst = extendsClassName ? [t.tSExpressionWithTypeArguments(t.identifier(extendsClassName))] : [];
  return t.exportNamedDeclaration(t.tsInterfaceDeclaration(t.identifier(className), null, extendsAst, t.tSInterfaceBody([// contract address
  t.tSPropertySignature(t.identifier("contractAddress"), t.tsTypeAnnotation(t.tsStringKeyword()))].concat((0, _toConsumableArray2["default"])(methods)))));
};

exports.createExecuteInterface = createExecuteInterface;

var createPropertyFunctionWithObjectParams = function createPropertyFunctionWithObjectParams(methodName, responseType, jsonschema) {
  var obj = (0, _types2.createTypedObjectParams)(jsonschema);
  var func = {
    type: "TSFunctionType",
    typeAnnotation: (0, _utils.promiseTypeAnnotation)(responseType),
    parameters: obj ? [obj] : []
  };
  return t.tSPropertySignature(t.identifier(methodName), t.tsTypeAnnotation(func));
};

exports.createPropertyFunctionWithObjectParams = createPropertyFunctionWithObjectParams;

var createPropertyFunctionWithObjectParamsForExec = function createPropertyFunctionWithObjectParamsForExec(methodName, responseType, jsonschema) {
  var obj = (0, _types2.createTypedObjectParams)(jsonschema);
  var fixedParams = [(0, _babel.identifier)("funds", t.tsTypeAnnotation(t.tsTypeReference(t.identifier("Coins"))), true)];
  var func = {
    type: "TSFunctionType",
    typeAnnotation: (0, _utils.promiseTypeAnnotation)(responseType),
    parameters: obj ? [obj].concat(fixedParams) : fixedParams
  };
  return t.tSPropertySignature(t.identifier(methodName), t.tsTypeAnnotation(func));
};

exports.createPropertyFunctionWithObjectParamsForExec = createPropertyFunctionWithObjectParamsForExec;

var createQueryInterface = function createQueryInterface(className, queryMsg, responses) {
  var methods = (0, _utils.getMessageProperties)(queryMsg).map(function (jsonschema) {
    var underscoreName = Object.keys(jsonschema.properties)[0];
    var methodName = (0, _case.camel)(underscoreName);
    var queryMethodName = (0, _utils.convertToQueryMethod)(underscoreName);
    var responseType = (0, _case.pascal)("".concat(methodName, "Response")); // Support naming query responses exactly like the method, or without a preceding "Get".

    if (!responses.includes(responseType)) {
      var modifiedMethodName = methodName.replace('get', '');
      responseType = (0, _case.pascal)("".concat(modifiedMethodName, "Response"));
    }

    return createPropertyFunctionWithObjectParams(queryMethodName, responseType, jsonschema.properties[underscoreName]);
  });
  return t.exportNamedDeclaration(t.tsInterfaceDeclaration(t.identifier(className), null, [], t.tSInterfaceBody([t.tSPropertySignature(t.identifier("contractAddress"), t.tsTypeAnnotation(t.tsStringKeyword()))].concat((0, _toConsumableArray2["default"])(methods)))));
};

exports.createQueryInterface = createQueryInterface;

var createTypeOrInterface = function createTypeOrInterface(Type, jsonschema) {
  var _jsonschema$propertie3;

  if (jsonschema.type !== "object") {
    if (!jsonschema.type) {
      return t.exportNamedDeclaration(t.tsTypeAliasDeclaration(t.identifier(Type), null, t.tsTypeReference(t.identifier(jsonschema.title))));
    }

    return t.exportNamedDeclaration(t.tsTypeAliasDeclaration(t.identifier(Type), null, (0, _types2.getType)(jsonschema.type)));
  }

  var props = Object.keys((_jsonschema$propertie3 = jsonschema.properties) !== null && _jsonschema$propertie3 !== void 0 ? _jsonschema$propertie3 : {}).map(function (prop) {
    var _getPropertyType = (0, _types2.getPropertyType)(jsonschema, prop),
        type = _getPropertyType.type,
        optional = _getPropertyType.optional;

    return (0, _babel.propertySignature)((0, _case.camel)(prop), t.tsTypeAnnotation(type), optional);
  });
  return t.exportNamedDeclaration(t.tsInterfaceDeclaration(t.identifier(Type), null, [], t.tsInterfaceBody((0, _toConsumableArray2["default"])(props))));
};

exports.createTypeOrInterface = createTypeOrInterface;

var createTypeInterface = function createTypeInterface(jsonschema) {
  var Type = jsonschema.title;
  return createTypeOrInterface(Type, jsonschema);
};

exports.createTypeInterface = createTypeInterface;