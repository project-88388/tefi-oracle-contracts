"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const cli_ux_1 = tslib_1.__importDefault(require("cli-ux"));
const boxen_1 = tslib_1.__importDefault(require("boxen"));
const semver_1 = tslib_1.__importDefault(require("semver"));
const dedent_1 = tslib_1.__importDefault(require("dedent"));
const child_process_1 = require("child_process");
const terminal_overwrite_1 = tslib_1.__importDefault(require("terminal-overwrite"));
const stringio_1 = require("@rauschma/stringio");
/** TerrainCLI offers default log styling for terrain commands. */
class TerrainCLI {
    constructor(prefix, anykeyStyle, successStyle, alertStyle, errorStyle, variableStyle) {
        this.prefix = prefix;
        this.anykeyStyle = anykeyStyle;
        this.successStyle = successStyle;
        this.alertStyle = alertStyle;
        this.errorStyle = errorStyle;
        this.variableStyle = variableStyle;
    }
    // Message box styling.
    messageBox(msg, msgStyle, title, emoji, msgBoxWidth = 60, variableStyle = this.variableStyle) {
        // Regex replace for text wrapping.
        const textWrapMsg = msg.replace(new RegExp(`(?![^\\n]{1,${msgBoxWidth}}$)([^\\n]{1,${msgBoxWidth}})\\s`, 'g'), '$1\n');
        // Replace variables, surrounded by double quotes, by the stylized variable.
        const variableRegex = /"(.+?)"/g;
        const varHighlightMsg = textWrapMsg.replace(variableRegex, variableStyle('$1'));
        // Return stylized string inside of 'boxen' object for display in terminal.
        return msgStyle((0, boxen_1.default)(varHighlightMsg, {
            title: (0, chalk_1.default) `{bold ${emoji} ${title}}`,
            titleAlignment: 'left',
            padding: 1,
            margin: 1,
        }));
    }
    // await TerrainCLI.anykey(anykeyMsg) styling.
    async anykey(anykeyMsg = '') {
        await cli_ux_1.default.anykey(`\n${this.prefix} ${this.anykeyStyle(`${anykeyMsg}`)}`);
    }
    // TerrainCLI.success(successMsg) styling.
    success(successMsg = '', title = '', emoji = 'âœ¨') {
        cli_ux_1.default.log(this.messageBox(successMsg, this.successStyle, title, emoji));
    }
    // TerrainCLI.error(errorMsg) styling.
    error(errorMsg = '', title = '', emoji = 'ðŸš¨') {
        cli_ux_1.default.log(this.messageBox(errorMsg, this.errorStyle, title, emoji, 46, chalk_1.default.green));
        process.exit();
    }
    // TerrainCLI.alert(alertMsg, title, maxWidth) styling
    alert(alertMsg = '', title = '', emoji = 'ðŸ‘‹') {
        cli_ux_1.default.log(this.messageBox(alertMsg, this.alertStyle, title, emoji));
    }
    // TerrainCLI.nodeVersionCheck() styling.
    nodeVersionCheck() {
        if (!semver_1.default.satisfies(process.version, '^16')) {
            this.error((0, dedent_1.default) `
          Terrain requires "Node version 16"!\n
          Please switch your version of Node before running Terrain commands.\n
          If you are utilizing nvm, simply use the following command:\n
          "nvm use 16"
        `, 'Incompatible Node Version');
            process.exit();
        }
    }
    // Parse cargo command output to only display progress bar.
    // eslint-disable-next-line class-methods-use-this
    async parseAndDisplayProgressBar(readable) {
        var _a, e_1, _b, _c;
        try {
            // eslint-disable-next-line no-restricted-syntax
            for (var _d = true, _e = tslib_1.__asyncValues((0, stringio_1.chunksToLinesAsync)(readable)), _f; _f = await _e.next(), _a = _f.done, !_a;) {
                _c = _f.value;
                _d = false;
                try {
                    const line = _c;
                    const chompedLine = (0, stringio_1.chomp)(line).split('\r');
                    // eslint-disable-next-line no-restricted-syntax
                    for (const splitLine of chompedLine) {
                        if (splitLine.includes('Building')) {
                            (0, terminal_overwrite_1.default)(splitLine);
                        }
                    }
                }
                finally {
                    _d = true;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = _e.return)) await _b.call(_e);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    // Run supplied cargo command with custom output.
    async runCargoCommand(command) {
        var _a;
        // stdio params: ['stdin', 'stdout', 'stderr'].
        const source = (0, child_process_1.spawn)('cargo', [command, '--color', 'always'], {
            env: Object.assign(Object.assign({}, process.env), { CARGO_TERM_PROGRESS_WHEN: 'always', CARGO_TERM_PROGRESS_WIDTH: (_a = process.stdout.columns) === null || _a === void 0 ? void 0 : _a.toString() }),
            stdio: ['ignore', 'ignore', 'pipe'],
        });
        // Only print progress bar and exclude all verbose output from Cargo.
        await this.parseAndDisplayProgressBar(source.stderr);
    }
}
exports.default = new TerrainCLI('ðŸ‘‰', chalk_1.default.cyan, chalk_1.default.green, chalk_1.default.blue, chalk_1.default.yellow, chalk_1.default.yellow);
