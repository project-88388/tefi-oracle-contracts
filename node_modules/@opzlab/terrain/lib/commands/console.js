"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const command_1 = require("@oclif/command");
const path_1 = require("path");
const fs_1 = require("fs");
const repl_1 = require("repl");
const terrajs = tslib_1.__importStar(require("@terra-money/feather.js"));
const env_1 = require("../lib/env");
const flag_1 = require("../lib/flag");
const TerrainCLI_1 = tslib_1.__importDefault(require("../TerrainCLI"));
const runCommand_1 = tslib_1.__importDefault(require("../lib/runCommand"));
const config_1 = require("../config");
// Needed for Terrain to be able to require typescript modules.
require('ts-node').register({
    // Don't actually check types of libs.
    transpileOnly: true,
    // Make sure we don't double transpile source code.
    ignore: ['(?:^|/)node_modules/', 'src/commands/.*\\.ts', 'src/lib/.*\\.ts'],
});
class Console extends command_1.Command {
    async run() {
        const { flags } = this.parse(Console);
        const { prefix, network } = (0, config_1.loadGlobalConfig)();
        // Command execution path.
        const execPath = 'lib';
        // Command to be performed.
        const command = async () => {
            var _a;
            const env = (0, env_1.getEnv)((0, path_1.join)(process.cwd(), flags['keys-path']), (0, path_1.join)(process.cwd(), flags['refs-path']), flags.network || network, flags.prefix || prefix, flags.signer);
            // eslint-disable-next-line import/no-dynamic-require, global-require
            let Lib = await Promise.resolve(`${(0, path_1.join)(process.cwd(), execPath)}`).then(s => tslib_1.__importStar(require(s)));
            let libInstance;
            // Detect if a default export exists and use that.
            if (Lib === null || Lib === void 0 ? void 0 : Lib.default) {
                Lib = Lib.default;
            }
            // Need the new keyword if Lib is a class.
            if (typeof Lib === 'function' && ((_a = Lib.prototype) === null || _a === void 0 ? void 0 : _a.constructor)) {
                libInstance = new Lib(env);
            }
            else {
                libInstance = Lib(env);
            }
            // for repl server
            const { config, refs, wallets, client, } = env;
            const r = (0, repl_1.start)({ prompt: 'terrain > ', useColors: true });
            const def = (name, value) => Object.defineProperty(r.context, name, {
                configurable: false,
                enumerable: true,
                value,
            });
            def('config', config);
            def('refs', refs);
            def('wallets', wallets);
            def('client', client);
            def('terrajs', terrajs);
            def('lib', libInstance);
        };
        // Error check to be performed upon each backtrack iteration.
        const errorCheck = () => {
            if ((0, fs_1.existsSync)('contracts') && !(0, fs_1.existsSync)(execPath)) {
                TerrainCLI_1.default.error(`Execution directory "${execPath}" not available in root application path.`, 'Execution Path Not Found');
            }
        };
        // Attempt to execute command while backtracking through file tree.
        await (0, runCommand_1.default)(execPath, command, errorCheck);
    }
}
Console.description = 'Start a repl console that provides context and convenient utilities to interact with the blockchain and your contracts.';
Console.flags = Object.assign({ signer: flag_1.signer,
    network: flag_1.network,
    prefix: flag_1.prefix }, flag_1.terrainPaths);
Console.args = [];
exports.default = Console;
