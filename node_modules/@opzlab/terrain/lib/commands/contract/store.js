"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const command_1 = require("@oclif/command");
const dedent_1 = tslib_1.__importDefault(require("dedent"));
const feather_js_1 = require("@terra-money/feather.js");
const fs_1 = require("fs");
const path_1 = require("path");
const config_1 = require("../../config");
const deployment_1 = require("../../lib/deployment");
const signer_1 = require("../../lib/signer");
const flag = tslib_1.__importStar(require("../../lib/flag"));
const TerrainCLI_1 = tslib_1.__importDefault(require("../../TerrainCLI"));
const runCommand_1 = tslib_1.__importDefault(require("../../lib/runCommand"));
class CodeStore extends command_1.Command {
    async run() {
        const { args, flags } = this.parse(CodeStore);
        // Command execution path.
        // Command to be performed.
        const command = async () => {
            const connections = (0, config_1.loadConnections)(flags.prefix);
            const config = (0, config_1.loadConfig)();
            const conf = config(flags.network, args.contract);
            const connection = connections(flags.network);
            const lcd = new feather_js_1.LCDClient({ [connection.chainID]: connection });
            const signer = await (0, signer_1.getSigner)({
                network: flags.network,
                signerId: flags.signer,
                keysPath: flags['keys-path'],
                lcd,
                prefix: flags.prefix,
            });
            await (0, deployment_1.storeCode)({
                conf,
                noRebuild: flags['no-rebuild'],
                contract: args.contract,
                signer,
                network: flags.network,
                refsPath: flags['refs-path'],
                lcd,
                codeId: flags['code-id'],
                prefix: flags.prefix,
            });
        };
        // Error check to be performed upon each backtrack iteration.
        const errorCheck = () => {
            if ((0, fs_1.existsSync)('contracts')
                && !(0, fs_1.existsSync)((0, path_1.join)('contracts', args.contract))) {
                TerrainCLI_1.default.error(`Contract "${args.contract}" not available in "contracts" directory.`, 'Contract Unavailable');
            }
        };
        // Message to be displayed upon successful command execution.
        const successMessage = () => {
            TerrainCLI_1.default.success((0, dedent_1.default) `
        The Wasm bytecode for contract "${args.contract}" was successfully stored on "${flags.network}".\n
        The next step is to instantiate the contract:\n
        "terrain contract:instantiate ${args.contract} --signer <signer-wallet>" "--network <desired-network>"\n
        "NOTE:" To instantiate your contract on the "LocalTerra" network utilizing the preconfigured test wallet "test1" as the signer, use the following command:\n
        "terrain contract:instantiate ${args.contract}"
      `, 'Wasm Bytecode Stored');
        };
        // Attempt to execute command while backtracking through file tree.
        await (0, runCommand_1.default)(config_1.CONFIG_FILE_NAME, command, errorCheck, successMessage);
    }
}
CodeStore.description = 'Store code on chain.';
CodeStore.flags = Object.assign(Object.assign({ 'no-rebuild': flag.noRebuild, 'code-id': flag.codeId }, flag.tx), flag.terrainPaths);
CodeStore.args = [{ name: 'contract', required: true }];
exports.default = CodeStore;
