"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.task = void 0;
const tslib_1 = require("tslib");
const command_1 = require("@oclif/command");
const path_1 = require("path");
const cli_ux_1 = require("cli-ux");
const fs_1 = require("fs");
const env_1 = require("../../lib/env");
const flag = tslib_1.__importStar(require("../../lib/flag"));
const runScript_1 = tslib_1.__importDefault(require("../../lib/runScript"));
const runCommand_1 = tslib_1.__importDefault(require("../../lib/runCommand"));
const TerrainCLI_1 = tslib_1.__importDefault(require("../../TerrainCLI"));
const config_1 = require("../../config");
const task = async (fn) => {
    try {
        await fn((0, env_1.getEnv)(process.env.keysPath || '', process.env.refsPath || '', process.env.network || '', process.env.prefix || '', process.env.signer || ''));
    }
    catch (err) {
        if (err instanceof Error) {
            cli_ux_1.cli.error(err);
        }
        if (typeof err === 'string') {
            cli_ux_1.cli.error(err);
        }
        cli_ux_1.cli.error(`${err}`);
    }
};
exports.task = task;
class Run extends command_1.Command {
    async run() {
        const { args, flags } = this.parse(Run);
        // Command execution path.
        const execPath = (0, path_1.join)('tasks', `${args.task}.ts`);
        const configPath = (0, path_1.join)(process.cwd(), config_1.CONFIG_FILE_NAME);
        // Command to be performed.
        const command = async () => new Promise((resolve, reject) => {
            (0, runScript_1.default)(execPath, {
                configPath,
                keysPath: (0, path_1.join)(process.cwd(), flags['keys-path']),
                refsPath: (0, path_1.join)(process.cwd(), flags['refs-path']),
                network: flags.network,
                prefix: flags.prefix,
                signer: flags.signer,
            }, (err) => {
                if (err)
                    reject(err);
                resolve();
            });
        });
        // Error check to be performed upon each backtrack iteration.
        const errorCheck = async () => {
            if ((0, fs_1.existsSync)('tasks') && !(0, fs_1.existsSync)(execPath)) {
                const jsExecutablePath = (0, path_1.join)('tasks', `${args.task}.js`);
                if ((0, fs_1.existsSync)(jsExecutablePath)) {
                    return new Promise((resolve, reject) => {
                        (0, runScript_1.default)(jsExecutablePath, {
                            configPath,
                            keysPath: (0, path_1.join)(process.cwd(), flags['keys-path']),
                            refsPath: (0, path_1.join)(process.cwd(), flags['refs-path']),
                            network: flags.network,
                            prefix: flags.prefix,
                            signer: flags.signer,
                        }, (err) => {
                            if (err)
                                reject(err);
                            resolve();
                        });
                    });
                }
                TerrainCLI_1.default.error(`Task "${args.task}" not available in "tasks" directory.`, 'Task Not Found');
            }
            return null;
        };
        // Attempt to execute command while backtracking through file tree.
        await (0, runCommand_1.default)(execPath, command, errorCheck);
    }
}
Run.description = 'run predefined task';
Run.flags = Object.assign(Object.assign({}, flag.tx), flag.terrainPaths);
Run.args = [{ name: 'task' }];
exports.default = Run;
