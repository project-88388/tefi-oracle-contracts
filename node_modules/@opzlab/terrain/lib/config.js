"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.saveRefs = exports.loadRefs = exports.loadKeys = exports.loadGlobalConfig = exports.loadConfig = exports.loadConnections = exports.readConfig = exports.saveConfig = exports.config = exports.connection = exports.GLOBAL_CONFIG = exports.CONFIG_FILE_NAME = void 0;
const tslib_1 = require("tslib");
const R = tslib_1.__importStar(require("ramda"));
const fs = tslib_1.__importStar(require("fs-extra"));
const feather_js_1 = require("@terra-money/feather.js");
const cli_ux_1 = require("cli-ux");
const path_1 = tslib_1.__importDefault(require("path"));
const TerrainCLI_1 = tslib_1.__importDefault(require("./TerrainCLI"));
exports.CONFIG_FILE_NAME = 'config.terrain.json';
exports.GLOBAL_CONFIG = {
    global: {
        useCargoWorkspace: false,
        prefix: 'terra',
        network: 'localterra',
        base: {
            instantiation: {
                instantiateMsg: {
                    count: 0,
                },
            },
        },
    },
};
const connection = (networks, prefix) => (network) => {
    const chainID = Object.keys(networks[network])
        .find((chainID) => networks[network][chainID].prefix === prefix);
    if (!chainID) {
        TerrainCLI_1.default.error(`no chain with network "${network}" with prefix "${prefix}" not found in config`);
        process.exit();
    }
    return networks[network][chainID];
};
exports.connection = connection;
const config = (allConfig) => (network, contract) => {
    const globalBaseConfig = (allConfig.global && allConfig.global.base) || {};
    const globalContractConfig = (allConfig.global
        && allConfig.global.contracts
        && allConfig.global.contracts[contract]) || {};
    const baseConfig = (allConfig[network] && allConfig[network].base) || {};
    const contractConfig = (allConfig[network]
        && allConfig[network].contracts
        && allConfig[network].contracts[contract]) || {};
    return [
        allConfig.global.base,
        globalBaseConfig,
        globalContractConfig,
        baseConfig,
        contractConfig,
    ].reduce(R.mergeDeepRight);
};
exports.config = config;
const saveConfig = (valuePath, value, path) => {
    const conf = fs.readJSONSync(path);
    const updated = R.set(R.lensPath(valuePath), value, conf);
    fs.writeJSONSync(path, updated, { spaces: 2 });
};
exports.saveConfig = saveConfig;
const readConfig = () => {
    let currentPath = process.cwd();
    // eslint-disable-next-line no-plusplus
    for (let i = 0; i < 5; i += 1) {
        const configPath = path_1.default.join(currentPath, exports.CONFIG_FILE_NAME);
        try {
            const config = fs.readJSONSync(configPath);
            return config;
        }
        catch (error) {
            if (error.code !== 'ENOENT') {
                return cli_ux_1.cli.error(`Error reading configuration from ${configPath}: ${error.message}`);
            }
        }
        currentPath = path_1.default.resolve(currentPath, '..');
    }
    return exports.GLOBAL_CONFIG;
};
exports.readConfig = readConfig;
const loadConnections = (prefix) => (0, exports.connection)((0, exports.readConfig)(), prefix);
exports.loadConnections = loadConnections;
const loadConfig = () => (0, exports.config)((0, exports.readConfig)());
exports.loadConfig = loadConfig;
const loadGlobalConfig = () => (({ global: { useCargoWorkspace, prefix, network, }, }) => ({ useCargoWorkspace, prefix, network }))((0, exports.readConfig)());
exports.loadGlobalConfig = loadGlobalConfig;
const loadKeys = (path) => {
    // eslint-disable-next-line import/no-dynamic-require, global-require
    const keys = require(path);
    return R.map((w) => {
        if (w.privateKey) {
            return new feather_js_1.RawKey(Buffer.from(w.privateKey, 'base64'));
        }
        if (w.mnemonic) {
            return new feather_js_1.MnemonicKey(w);
        }
        return cli_ux_1.cli.error('Error: Key must be defined with either `privateKey` or `mnemonic`');
    }, keys);
};
exports.loadKeys = loadKeys;
const loadRefs = (path) => fs.readJSONSync(path);
exports.loadRefs = loadRefs;
const saveRefs = (refs, path) => {
    fs.writeJSONSync(path, refs, { spaces: 2 });
};
exports.saveRefs = saveRefs;
