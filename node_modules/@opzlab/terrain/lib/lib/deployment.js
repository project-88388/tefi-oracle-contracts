"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.migrate = exports.instantiate = exports.storeCode = exports.optimize = exports.build = void 0;
const tslib_1 = require("tslib");
/* eslint-disable no-await-in-loop */
const os_1 = tslib_1.__importDefault(require("os"));
const feather_js_1 = require("@terra-money/feather.js");
const toml_1 = require("toml");
const hyperlinker_1 = tslib_1.__importDefault(require("hyperlinker"));
const child_process_1 = require("child_process");
const fs = tslib_1.__importStar(require("fs-extra"));
const cli_ux_1 = require("cli-ux");
const YAML = tslib_1.__importStar(require("yaml"));
const dedent_1 = tslib_1.__importDefault(require("dedent"));
const path_1 = tslib_1.__importDefault(require("path"));
const config_1 = require("../config");
const util_1 = require("../util");
const TerrainCLI_1 = tslib_1.__importDefault(require("../TerrainCLI"));
const useARM64_1 = tslib_1.__importDefault(require("./useARM64"));
const build = async ({ contract }) => {
    const startingDirectory = process.cwd();
    const folder = path_1.default.join('contracts', contract);
    process.chdir(folder);
    const { package: pkg } = (0, toml_1.parse)(fs.readFileSync('./Cargo.toml', 'utf-8'));
    if (contract !== pkg.name) {
        cli_ux_1.cli.error(`Change the package name in Cargo.toml to ${contract} to build`);
    }
    await TerrainCLI_1.default.runCargoCommand('wasm');
    await TerrainCLI_1.default.runCargoCommand('schema');
    process.chdir(startingDirectory);
};
exports.build = build;
const execDockerOptimization = (image, cache) => {
    const dir = os_1.default.platform() === 'win32' ? '%cd%' : '$(pwd)';
    try {
        (0, child_process_1.execSync)(`docker run --rm -v "${dir}":/code \
        --mount type=volume,source="${cache}_cache",target=/code/target \
        --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \
        ${image}`, { stdio: 'inherit' });
    }
    catch (err) {
        TerrainCLI_1.default.error((0, dedent_1.default) `
      Please ensure that "Docker" is installed and running in the background before executing this command:\n
      "${(0, hyperlinker_1.default)('https://docs.docker.com/get-docker/', 'https://docs.docker.com/get-docker/')}"
    `, 'Docker Unavailable');
    }
};
const optimizeContract = async ({ contract, arm64, }) => {
    const startingDirectory = process.cwd();
    const folder = path_1.default.join('contracts', contract);
    process.chdir(folder);
    const image = `cosmwasm/rust-optimizer${arm64 ? '-arm64' : ''}:0.14.0`;
    execDockerOptimization(image, contract);
    process.chdir(startingDirectory);
};
const optimizeWorkspace = async ({ contract, arm64, }) => {
    const image = `cosmwasm/workspace-optimizer${arm64 ? '-arm64' : ''}:0.12.6`;
    execDockerOptimization(image, contract);
};
const optimize = async ({ contract, useCargoWorkspace, network, }) => {
    const arm64 = (0, useARM64_1.default)(network);
    if (useCargoWorkspace) {
        optimizeWorkspace({ contract, arm64 });
    }
    else {
        optimizeContract({ contract, arm64 });
    }
};
exports.optimize = optimize;
const storeCode = async ({ contract, signer, network, refsPath, lcd, codeId, noRebuild, useCargoWorkspace, memo, prefix, }) => {
    const arm64 = (0, useARM64_1.default)(network);
    const connections = (0, config_1.loadConnections)(prefix);
    const { chainID } = connections(network);
    if (!noRebuild) {
        await (0, exports.build)({ contract });
        await (0, exports.optimize)({ contract, useCargoWorkspace, network });
    }
    let wasmByteCodeFilename = `${contract.replace(/-/g, '_')}`;
    // rust-optimizer-arm64 produces a file with the `-aarch64` suffix.
    if (arm64) {
        wasmByteCodeFilename += '-aarch64';
    }
    wasmByteCodeFilename += '.wasm';
    // Create boolean to check if user is attempting to store ARM64 wasm binary on mainnet.
    const wasmFiles = fs.readdirSync(path_1.default.join('contracts', contract, 'artifacts'));
    const storingARM64Mainnet = !wasmFiles.includes(wasmByteCodeFilename)
        && process.arch === 'arm64'
        && network === 'mainnet';
    // Check if user is attempting to store ARM64 wasm binary on mainnet.
    // If so, reoptimize to default wasm binary to store on mainnet.
    if (storingARM64Mainnet) {
        TerrainCLI_1.default.error((0, dedent_1.default) `
      ARM64 wasm files should not be stored on "Mainnet". Rebuilding contract to deploy default wasm binary.
    `, 'ARM64 Wasm Detected');
        await (0, exports.optimize)({ contract, useCargoWorkspace, network });
    }
    const artifactFileName = useCargoWorkspace
        ? path_1.default.join('artifacts', wasmByteCodeFilename)
        : path_1.default.join('contracts', contract, 'artifacts', wasmByteCodeFilename);
    const wasmByteCode = fs.readFileSync(artifactFileName).toString('base64');
    cli_ux_1.cli.action.start('storing wasm bytecode on chain');
    const storeCodeTx = await signer.createAndSignTx({
        chainID,
        memo,
        msgs: [
            codeId
                ? new feather_js_1.MsgMigrateCode(signer.key.accAddress(prefix), codeId, wasmByteCode)
                : new feather_js_1.MsgStoreCode(signer.key.accAddress(prefix), wasmByteCode),
        ],
    });
    const res = await lcd.tx.broadcast(storeCodeTx, chainID);
    cli_ux_1.cli.action.stop();
    try {
        const savedCodeId = JSON.parse((res && res.raw_log) || '')[0]
            .events.find((msg) => msg.type === 'store_code')
            .attributes.find((attr) => attr.key === 'code_id').value;
        const updatedRefs = (0, util_1.setCodeId)(network, chainID, contract, savedCodeId)((0, config_1.loadRefs)(refsPath));
        (0, config_1.saveRefs)(updatedRefs, refsPath);
        cli_ux_1.cli.log(`code is stored at code id: ${savedCodeId}`);
        return savedCodeId;
    }
    catch (error) {
        if (error instanceof SyntaxError) {
            cli_ux_1.cli.error(res.raw_log);
        }
        else {
            cli_ux_1.cli.error(`Unexpected Error: ${error}`);
        }
    }
};
exports.storeCode = storeCode;
const instantiate = async ({ conf, refsPath, network, lcd, signer, admin, contract, codeId, instanceId, sequence, prefix, memo, }) => {
    var _a;
    const { instantiation } = conf;
    const connections = (0, config_1.loadConnections)(prefix);
    const { chainID } = connections(network);
    // Ensure contract refs are available in refs.terrain.json.
    const refs = (0, config_1.loadRefs)(refsPath);
    if (!(network in refs) || !(contract in refs[network][chainID])) {
        const name = `${network[0].toUpperCase()}${network.substring(1)}`;
        TerrainCLI_1.default.error(`Contract "${contract}" has not yet been stored on the "${name}" network with prefix "${prefix}.`, 'Contract Not Stored');
    }
    const actualCodeId = codeId || refs[network][chainID][contract].codeId;
    cli_ux_1.cli.action.start(`instantiating contract with msg: ${JSON.stringify(instantiation.instantiateMsg)}`);
    // Allow manual account sequences.
    const manualSequence = sequence || (await signer.sequence(chainID));
    // Create signerData and txOptions for fee estimation.
    const accountInfo = await lcd.auth.accountInfo(signer.key.accAddress(prefix));
    const signerData = [
        {
            sequenceNumber: manualSequence,
            publicKey: accountInfo.getPublicKey(),
        },
    ];
    const feeDenom = (0, util_1.getFeeDenom)(network, prefix);
    const txOptions = {
        chainID,
        memo,
        msgs: [
            new feather_js_1.MsgInstantiateContract(signer.key.accAddress(prefix), admin, // can migrate
            actualCodeId, instantiation.instantiateMsg, undefined, 'Instantiate'),
        ],
    };
    if (!txOptions.feeDenoms) {
        txOptions.feeDenoms = [feeDenom];
    }
    if (network === 'mainnet') {
        const feeEstimate = await lcd.tx.estimateFee(signerData, txOptions);
        const gasFee = Number(feeEstimate.amount.get(txOptions.feeDenoms[0]).amount) / 1000000;
        await TerrainCLI_1.default.anykey(`The gas needed to deploy the '${contract}' contact is estimated to be ${gasFee} ${feeDenom}. Press any key to continue or "ctl+c" to exit`);
    }
    const instantiateTx = await signer.createAndSignTx(Object.assign({ sequence: manualSequence }, txOptions));
    const res = await lcd.tx.broadcast(instantiateTx, chainID);
    let log = [];
    try {
        log = JSON.parse(res.raw_log);
    }
    catch (error) {
        cli_ux_1.cli.action.stop();
        if (error instanceof SyntaxError && res) {
            cli_ux_1.cli.error(res.raw_log);
        }
        else {
            cli_ux_1.cli.error(`Unexpected Error: ${error}`);
        }
    }
    cli_ux_1.cli.action.stop();
    const event = (_a = log[0].events.find((e) => e.type === 'instantiate_contract')) !== null && _a !== void 0 ? _a : log[0].events.find((e) => e.type === 'instantiate');
    const contractAddress = event.attributes.find((attr) => attr.key === '_contract_address').value;
    const updatedRefs = (0, util_1.setContractAddress)(network, chainID, contract, instanceId || 'default', contractAddress)((0, config_1.loadRefs)(refsPath));
    (0, config_1.saveRefs)(updatedRefs, refsPath);
    cli_ux_1.cli.log(YAML.stringify(log));
    return contractAddress;
};
exports.instantiate = instantiate;
const migrate = async ({ conf, refsPath, lcd, signer, contract, codeId, network, instanceId, prefix, }) => {
    const { instantiation } = conf;
    const refs = (0, config_1.loadRefs)(refsPath);
    const connections = (0, config_1.loadConnections)(prefix);
    const { chainID } = connections(network);
    const contractAddress = refs[network][chainID][contract].contractAddresses[instanceId];
    cli_ux_1.cli.action.start(`migrating contract with address ${contractAddress} to code id: ${codeId}`);
    const migrateTx = await signer.createAndSignTx({
        chainID,
        msgs: [
            new feather_js_1.MsgMigrateContract(signer.key.accAddress(prefix), contractAddress, codeId, instantiation.instantiateMsg),
        ],
    });
    const resInstant = await lcd.tx.broadcast(migrateTx, chainID);
    let log = [];
    try {
        log = JSON.parse(resInstant.raw_log);
    }
    catch (error) {
        cli_ux_1.cli.action.stop();
        if (error instanceof SyntaxError) {
            cli_ux_1.cli.error(resInstant.raw_log);
        }
        else {
            cli_ux_1.cli.error(`Unexpected Error: ${error}`);
        }
    }
    cli_ux_1.cli.action.stop();
    const updatedRefs = (0, util_1.setContractAddress)(network, chainID, contract, instanceId, contractAddress)((0, config_1.loadRefs)(refsPath));
    (0, config_1.saveRefs)(updatedRefs, refsPath);
    cli_ux_1.cli.log(YAML.stringify(log));
};
exports.migrate = migrate;
