"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tx = exports.terrainPaths = exports.frontendRefsPath = exports.keysPath = exports.refsPath = exports.configPath = exports.codeId = exports.memo = exports.prefix = exports.network = exports.instanceId = exports.noRebuild = exports.signer = void 0;
const command_1 = require("@oclif/command");
const config_1 = require("../config");
exports.signer = command_1.flags.string({ default: 'test1' });
const globalConfig = (0, config_1.loadGlobalConfig)();
exports.noRebuild = command_1.flags.boolean({
    description: 'deploy the wasm bytecode as is.',
    default: false,
});
exports.instanceId = command_1.flags.string({ default: 'default', description: 'enable management of multiple instances of the same contract' });
exports.network = command_1.flags.string({ default: globalConfig.network || 'localterra', description: 'network to deploy to from config.terrain.json', options: ['mainnet', 'testnet', 'localterra'] });
exports.prefix = command_1.flags.string({ default: globalConfig.prefix || 'terra', description: 'address prefix of target chain, all chains supported by Station are supported by terrain' });
exports.memo = command_1.flags.string({ default: 'terrain' });
exports.codeId = command_1.flags.integer({ description: 'specific codeId to instantiate', default: 0 });
exports.configPath = command_1.flags.string({ default: './config.terrain.json' });
exports.refsPath = command_1.flags.string({ default: './refs.terrain.json' });
exports.keysPath = command_1.flags.string({ default: './keys.terrain.js' });
exports.frontendRefsPath = command_1.flags.string({
    default: './frontend/src/',
});
// These three are commonly used together.
exports.terrainPaths = {
    'refs-path': exports.refsPath,
    'keys-path': exports.keysPath,
};
exports.tx = {
    signer: exports.signer,
    network: exports.network,
    prefix: exports.prefix,
};
