"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class DataParser {
    constructor(options) {
        var _a, _b;
        this.parse = (zip) => {
            const templateTags = this.prepareTemplateTags();
            for (const zipEntry of zip.getEntries()) {
                if (this.shouldReplaceTags(zipEntry.entryName)) {
                    let text = zip.readAsText(zipEntry);
                    if (text.includes(this.prefix)) {
                        for (const property in templateTags) {
                            const regex = new RegExp(property, "g");
                            const value = templateTags[property];
                            text = text.replace(regex, value);
                        }
                    }
                    zip.updateFile(zipEntry, Buffer.from(text));
                }
            }
            return zip;
        };
        this.prepareTemplateTags = () => {
            var _a;
            const entries = (_a = this.options.replace) === null || _a === void 0 ? void 0 : _a.entries;
            const parsedEntities = {};
            for (const key in entries) {
                const parsedKey = this.prefix + key + this.suffix;
                parsedEntities[parsedKey] = entries[key];
            }
            return parsedEntities;
        };
        this.shouldReplaceTags = (entryName) => {
            var _a;
            if (!!((_a = this.options) === null || _a === void 0 ? void 0 : _a.subFolder)) {
                return entryName.includes(this.options.subFolder);
            }
            return true;
        };
        this.options = options;
        this.prefix = ((_a = options.replace) === null || _a === void 0 ? void 0 : _a.prefix) ? options.replace.prefix : "{{";
        this.suffix = ((_b = options.replace) === null || _b === void 0 ? void 0 : _b.suffix) ? options.replace.suffix : "}}";
    }
}
exports.default = DataParser;
//# sourceMappingURL=DataParser.js.map