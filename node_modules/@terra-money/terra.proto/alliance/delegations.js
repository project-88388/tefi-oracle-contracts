"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AllianceValidatorInfo = exports.QueuedUndelegation = exports.Undelegation = exports.QueuedRedelegation = exports.Redelegation = exports.Delegation = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const coin_1 = require("../cosmos/base/v1beta1/coin");
const params_1 = require("../alliance/params");
exports.protobufPackage = "alliance.alliance";
const baseDelegation = {
    delegatorAddress: "",
    validatorAddress: "",
    denom: "",
    shares: "",
    lastRewardClaimHeight: long_1.default.UZERO,
};
exports.Delegation = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
            writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
            writer.uint32(18).string(message.validatorAddress);
        }
        if (message.denom !== "") {
            writer.uint32(26).string(message.denom);
        }
        if (message.shares !== "") {
            writer.uint32(34).string(message.shares);
        }
        for (const v of message.rewardHistory) {
            params_1.RewardHistory.encode(v, writer.uint32(42).fork()).ldelim();
        }
        if (!message.lastRewardClaimHeight.isZero()) {
            writer.uint32(48).uint64(message.lastRewardClaimHeight);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseDelegation);
        message.rewardHistory = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.delegatorAddress = reader.string();
                    break;
                case 2:
                    message.validatorAddress = reader.string();
                    break;
                case 3:
                    message.denom = reader.string();
                    break;
                case 4:
                    message.shares = reader.string();
                    break;
                case 5:
                    message.rewardHistory.push(params_1.RewardHistory.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.lastRewardClaimHeight = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseDelegation);
        message.rewardHistory = [];
        if (object.delegatorAddress !== undefined && object.delegatorAddress !== null) {
            message.delegatorAddress = String(object.delegatorAddress);
        }
        else {
            message.delegatorAddress = "";
        }
        if (object.validatorAddress !== undefined && object.validatorAddress !== null) {
            message.validatorAddress = String(object.validatorAddress);
        }
        else {
            message.validatorAddress = "";
        }
        if (object.denom !== undefined && object.denom !== null) {
            message.denom = String(object.denom);
        }
        else {
            message.denom = "";
        }
        if (object.shares !== undefined && object.shares !== null) {
            message.shares = String(object.shares);
        }
        else {
            message.shares = "";
        }
        if (object.rewardHistory !== undefined && object.rewardHistory !== null) {
            for (const e of object.rewardHistory) {
                message.rewardHistory.push(params_1.RewardHistory.fromJSON(e));
            }
        }
        if (object.lastRewardClaimHeight !== undefined && object.lastRewardClaimHeight !== null) {
            message.lastRewardClaimHeight = long_1.default.fromString(object.lastRewardClaimHeight);
        }
        else {
            message.lastRewardClaimHeight = long_1.default.UZERO;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.delegatorAddress !== undefined && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== undefined && (obj.validatorAddress = message.validatorAddress);
        message.denom !== undefined && (obj.denom = message.denom);
        message.shares !== undefined && (obj.shares = message.shares);
        if (message.rewardHistory) {
            obj.rewardHistory = message.rewardHistory.map((e) => (e ? params_1.RewardHistory.toJSON(e) : undefined));
        }
        else {
            obj.rewardHistory = [];
        }
        message.lastRewardClaimHeight !== undefined &&
            (obj.lastRewardClaimHeight = (message.lastRewardClaimHeight || long_1.default.UZERO).toString());
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseDelegation);
        message.rewardHistory = [];
        if (object.delegatorAddress !== undefined && object.delegatorAddress !== null) {
            message.delegatorAddress = object.delegatorAddress;
        }
        else {
            message.delegatorAddress = "";
        }
        if (object.validatorAddress !== undefined && object.validatorAddress !== null) {
            message.validatorAddress = object.validatorAddress;
        }
        else {
            message.validatorAddress = "";
        }
        if (object.denom !== undefined && object.denom !== null) {
            message.denom = object.denom;
        }
        else {
            message.denom = "";
        }
        if (object.shares !== undefined && object.shares !== null) {
            message.shares = object.shares;
        }
        else {
            message.shares = "";
        }
        if (object.rewardHistory !== undefined && object.rewardHistory !== null) {
            for (const e of object.rewardHistory) {
                message.rewardHistory.push(params_1.RewardHistory.fromPartial(e));
            }
        }
        if (object.lastRewardClaimHeight !== undefined && object.lastRewardClaimHeight !== null) {
            message.lastRewardClaimHeight = object.lastRewardClaimHeight;
        }
        else {
            message.lastRewardClaimHeight = long_1.default.UZERO;
        }
        return message;
    },
};
const baseRedelegation = { delegatorAddress: "", srcValidatorAddress: "", dstValidatorAddress: "" };
exports.Redelegation = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
            writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.srcValidatorAddress !== "") {
            writer.uint32(18).string(message.srcValidatorAddress);
        }
        if (message.dstValidatorAddress !== "") {
            writer.uint32(26).string(message.dstValidatorAddress);
        }
        if (message.balance !== undefined) {
            coin_1.Coin.encode(message.balance, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRedelegation);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.delegatorAddress = reader.string();
                    break;
                case 2:
                    message.srcValidatorAddress = reader.string();
                    break;
                case 3:
                    message.dstValidatorAddress = reader.string();
                    break;
                case 4:
                    message.balance = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseRedelegation);
        if (object.delegatorAddress !== undefined && object.delegatorAddress !== null) {
            message.delegatorAddress = String(object.delegatorAddress);
        }
        else {
            message.delegatorAddress = "";
        }
        if (object.srcValidatorAddress !== undefined && object.srcValidatorAddress !== null) {
            message.srcValidatorAddress = String(object.srcValidatorAddress);
        }
        else {
            message.srcValidatorAddress = "";
        }
        if (object.dstValidatorAddress !== undefined && object.dstValidatorAddress !== null) {
            message.dstValidatorAddress = String(object.dstValidatorAddress);
        }
        else {
            message.dstValidatorAddress = "";
        }
        if (object.balance !== undefined && object.balance !== null) {
            message.balance = coin_1.Coin.fromJSON(object.balance);
        }
        else {
            message.balance = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.delegatorAddress !== undefined && (obj.delegatorAddress = message.delegatorAddress);
        message.srcValidatorAddress !== undefined && (obj.srcValidatorAddress = message.srcValidatorAddress);
        message.dstValidatorAddress !== undefined && (obj.dstValidatorAddress = message.dstValidatorAddress);
        message.balance !== undefined &&
            (obj.balance = message.balance ? coin_1.Coin.toJSON(message.balance) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseRedelegation);
        if (object.delegatorAddress !== undefined && object.delegatorAddress !== null) {
            message.delegatorAddress = object.delegatorAddress;
        }
        else {
            message.delegatorAddress = "";
        }
        if (object.srcValidatorAddress !== undefined && object.srcValidatorAddress !== null) {
            message.srcValidatorAddress = object.srcValidatorAddress;
        }
        else {
            message.srcValidatorAddress = "";
        }
        if (object.dstValidatorAddress !== undefined && object.dstValidatorAddress !== null) {
            message.dstValidatorAddress = object.dstValidatorAddress;
        }
        else {
            message.dstValidatorAddress = "";
        }
        if (object.balance !== undefined && object.balance !== null) {
            message.balance = coin_1.Coin.fromPartial(object.balance);
        }
        else {
            message.balance = undefined;
        }
        return message;
    },
};
const baseQueuedRedelegation = {};
exports.QueuedRedelegation = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.entries) {
            exports.Redelegation.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueuedRedelegation);
        message.entries = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.entries.push(exports.Redelegation.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueuedRedelegation);
        message.entries = [];
        if (object.entries !== undefined && object.entries !== null) {
            for (const e of object.entries) {
                message.entries.push(exports.Redelegation.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.entries) {
            obj.entries = message.entries.map((e) => (e ? exports.Redelegation.toJSON(e) : undefined));
        }
        else {
            obj.entries = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueuedRedelegation);
        message.entries = [];
        if (object.entries !== undefined && object.entries !== null) {
            for (const e of object.entries) {
                message.entries.push(exports.Redelegation.fromPartial(e));
            }
        }
        return message;
    },
};
const baseUndelegation = { delegatorAddress: "", validatorAddress: "" };
exports.Undelegation = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
            writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
            writer.uint32(18).string(message.validatorAddress);
        }
        if (message.balance !== undefined) {
            coin_1.Coin.encode(message.balance, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseUndelegation);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.delegatorAddress = reader.string();
                    break;
                case 2:
                    message.validatorAddress = reader.string();
                    break;
                case 3:
                    message.balance = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseUndelegation);
        if (object.delegatorAddress !== undefined && object.delegatorAddress !== null) {
            message.delegatorAddress = String(object.delegatorAddress);
        }
        else {
            message.delegatorAddress = "";
        }
        if (object.validatorAddress !== undefined && object.validatorAddress !== null) {
            message.validatorAddress = String(object.validatorAddress);
        }
        else {
            message.validatorAddress = "";
        }
        if (object.balance !== undefined && object.balance !== null) {
            message.balance = coin_1.Coin.fromJSON(object.balance);
        }
        else {
            message.balance = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.delegatorAddress !== undefined && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== undefined && (obj.validatorAddress = message.validatorAddress);
        message.balance !== undefined &&
            (obj.balance = message.balance ? coin_1.Coin.toJSON(message.balance) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseUndelegation);
        if (object.delegatorAddress !== undefined && object.delegatorAddress !== null) {
            message.delegatorAddress = object.delegatorAddress;
        }
        else {
            message.delegatorAddress = "";
        }
        if (object.validatorAddress !== undefined && object.validatorAddress !== null) {
            message.validatorAddress = object.validatorAddress;
        }
        else {
            message.validatorAddress = "";
        }
        if (object.balance !== undefined && object.balance !== null) {
            message.balance = coin_1.Coin.fromPartial(object.balance);
        }
        else {
            message.balance = undefined;
        }
        return message;
    },
};
const baseQueuedUndelegation = {};
exports.QueuedUndelegation = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.entries) {
            exports.Undelegation.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueuedUndelegation);
        message.entries = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.entries.push(exports.Undelegation.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueuedUndelegation);
        message.entries = [];
        if (object.entries !== undefined && object.entries !== null) {
            for (const e of object.entries) {
                message.entries.push(exports.Undelegation.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.entries) {
            obj.entries = message.entries.map((e) => (e ? exports.Undelegation.toJSON(e) : undefined));
        }
        else {
            obj.entries = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueuedUndelegation);
        message.entries = [];
        if (object.entries !== undefined && object.entries !== null) {
            for (const e of object.entries) {
                message.entries.push(exports.Undelegation.fromPartial(e));
            }
        }
        return message;
    },
};
const baseAllianceValidatorInfo = {};
exports.AllianceValidatorInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.globalRewardHistory) {
            params_1.RewardHistory.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.totalDelegatorShares) {
            coin_1.DecCoin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.validatorShares) {
            coin_1.DecCoin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseAllianceValidatorInfo);
        message.globalRewardHistory = [];
        message.totalDelegatorShares = [];
        message.validatorShares = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.globalRewardHistory.push(params_1.RewardHistory.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.totalDelegatorShares.push(coin_1.DecCoin.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.validatorShares.push(coin_1.DecCoin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseAllianceValidatorInfo);
        message.globalRewardHistory = [];
        message.totalDelegatorShares = [];
        message.validatorShares = [];
        if (object.globalRewardHistory !== undefined && object.globalRewardHistory !== null) {
            for (const e of object.globalRewardHistory) {
                message.globalRewardHistory.push(params_1.RewardHistory.fromJSON(e));
            }
        }
        if (object.totalDelegatorShares !== undefined && object.totalDelegatorShares !== null) {
            for (const e of object.totalDelegatorShares) {
                message.totalDelegatorShares.push(coin_1.DecCoin.fromJSON(e));
            }
        }
        if (object.validatorShares !== undefined && object.validatorShares !== null) {
            for (const e of object.validatorShares) {
                message.validatorShares.push(coin_1.DecCoin.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.globalRewardHistory) {
            obj.globalRewardHistory = message.globalRewardHistory.map((e) => e ? params_1.RewardHistory.toJSON(e) : undefined);
        }
        else {
            obj.globalRewardHistory = [];
        }
        if (message.totalDelegatorShares) {
            obj.totalDelegatorShares = message.totalDelegatorShares.map((e) => (e ? coin_1.DecCoin.toJSON(e) : undefined));
        }
        else {
            obj.totalDelegatorShares = [];
        }
        if (message.validatorShares) {
            obj.validatorShares = message.validatorShares.map((e) => (e ? coin_1.DecCoin.toJSON(e) : undefined));
        }
        else {
            obj.validatorShares = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseAllianceValidatorInfo);
        message.globalRewardHistory = [];
        message.totalDelegatorShares = [];
        message.validatorShares = [];
        if (object.globalRewardHistory !== undefined && object.globalRewardHistory !== null) {
            for (const e of object.globalRewardHistory) {
                message.globalRewardHistory.push(params_1.RewardHistory.fromPartial(e));
            }
        }
        if (object.totalDelegatorShares !== undefined && object.totalDelegatorShares !== null) {
            for (const e of object.totalDelegatorShares) {
                message.totalDelegatorShares.push(coin_1.DecCoin.fromPartial(e));
            }
        }
        if (object.validatorShares !== undefined && object.validatorShares !== null) {
            for (const e of object.validatorShares) {
                message.validatorShares.push(coin_1.DecCoin.fromPartial(e));
            }
        }
        return message;
    },
};
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
//# sourceMappingURL=delegations.js.map