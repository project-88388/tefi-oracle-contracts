"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GrpcWebImpl = exports.MsgDesc = exports.MsgClientImpl = exports.GenesisState = exports.EpochUnbondingRecord = exports.HostZoneUnbonding = exports.DepositRecord = exports.NoData = exports.RecordsPacketData = exports.Params = exports.UserRedemptionRecord = exports.hostZoneUnbonding_StatusToJSON = exports.hostZoneUnbonding_StatusFromJSON = exports.HostZoneUnbonding_Status = exports.depositRecord_SourceToJSON = exports.depositRecord_SourceFromJSON = exports.DepositRecord_Source = exports.depositRecord_StatusToJSON = exports.depositRecord_StatusFromJSON = exports.DepositRecord_Status = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const grpc_web_1 = require("@improbable-eng/grpc-web");
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const browser_headers_1 = require("browser-headers");
exports.protobufPackage = "stride.records";
var DepositRecord_Status;
(function (DepositRecord_Status) {
    /** TRANSFER_QUEUE - in transfer queue to be sent to the delegation ICA */
    DepositRecord_Status[DepositRecord_Status["TRANSFER_QUEUE"] = 0] = "TRANSFER_QUEUE";
    /** TRANSFER_IN_PROGRESS - transfer in progress (IBC packet sent, ack not received) */
    DepositRecord_Status[DepositRecord_Status["TRANSFER_IN_PROGRESS"] = 2] = "TRANSFER_IN_PROGRESS";
    /** DELEGATION_QUEUE - in staking queue on delegation ICA */
    DepositRecord_Status[DepositRecord_Status["DELEGATION_QUEUE"] = 1] = "DELEGATION_QUEUE";
    /** DELEGATION_IN_PROGRESS - staking in progress (ICA packet sent, ack not received) */
    DepositRecord_Status[DepositRecord_Status["DELEGATION_IN_PROGRESS"] = 3] = "DELEGATION_IN_PROGRESS";
    DepositRecord_Status[DepositRecord_Status["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(DepositRecord_Status = exports.DepositRecord_Status || (exports.DepositRecord_Status = {}));
function depositRecord_StatusFromJSON(object) {
    switch (object) {
        case 0:
        case "TRANSFER_QUEUE":
            return DepositRecord_Status.TRANSFER_QUEUE;
        case 2:
        case "TRANSFER_IN_PROGRESS":
            return DepositRecord_Status.TRANSFER_IN_PROGRESS;
        case 1:
        case "DELEGATION_QUEUE":
            return DepositRecord_Status.DELEGATION_QUEUE;
        case 3:
        case "DELEGATION_IN_PROGRESS":
            return DepositRecord_Status.DELEGATION_IN_PROGRESS;
        case -1:
        case "UNRECOGNIZED":
        default:
            return DepositRecord_Status.UNRECOGNIZED;
    }
}
exports.depositRecord_StatusFromJSON = depositRecord_StatusFromJSON;
function depositRecord_StatusToJSON(object) {
    switch (object) {
        case DepositRecord_Status.TRANSFER_QUEUE:
            return "TRANSFER_QUEUE";
        case DepositRecord_Status.TRANSFER_IN_PROGRESS:
            return "TRANSFER_IN_PROGRESS";
        case DepositRecord_Status.DELEGATION_QUEUE:
            return "DELEGATION_QUEUE";
        case DepositRecord_Status.DELEGATION_IN_PROGRESS:
            return "DELEGATION_IN_PROGRESS";
        default:
            return "UNKNOWN";
    }
}
exports.depositRecord_StatusToJSON = depositRecord_StatusToJSON;
var DepositRecord_Source;
(function (DepositRecord_Source) {
    DepositRecord_Source[DepositRecord_Source["STRIDE"] = 0] = "STRIDE";
    DepositRecord_Source[DepositRecord_Source["WITHDRAWAL_ICA"] = 1] = "WITHDRAWAL_ICA";
    DepositRecord_Source[DepositRecord_Source["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(DepositRecord_Source = exports.DepositRecord_Source || (exports.DepositRecord_Source = {}));
function depositRecord_SourceFromJSON(object) {
    switch (object) {
        case 0:
        case "STRIDE":
            return DepositRecord_Source.STRIDE;
        case 1:
        case "WITHDRAWAL_ICA":
            return DepositRecord_Source.WITHDRAWAL_ICA;
        case -1:
        case "UNRECOGNIZED":
        default:
            return DepositRecord_Source.UNRECOGNIZED;
    }
}
exports.depositRecord_SourceFromJSON = depositRecord_SourceFromJSON;
function depositRecord_SourceToJSON(object) {
    switch (object) {
        case DepositRecord_Source.STRIDE:
            return "STRIDE";
        case DepositRecord_Source.WITHDRAWAL_ICA:
            return "WITHDRAWAL_ICA";
        default:
            return "UNKNOWN";
    }
}
exports.depositRecord_SourceToJSON = depositRecord_SourceToJSON;
var HostZoneUnbonding_Status;
(function (HostZoneUnbonding_Status) {
    /** UNBONDING_QUEUE - tokens bonded on delegate account */
    HostZoneUnbonding_Status[HostZoneUnbonding_Status["UNBONDING_QUEUE"] = 0] = "UNBONDING_QUEUE";
    HostZoneUnbonding_Status[HostZoneUnbonding_Status["UNBONDING_IN_PROGRESS"] = 3] = "UNBONDING_IN_PROGRESS";
    /** EXIT_TRANSFER_QUEUE - unbonding completed on delegate account */
    HostZoneUnbonding_Status[HostZoneUnbonding_Status["EXIT_TRANSFER_QUEUE"] = 1] = "EXIT_TRANSFER_QUEUE";
    HostZoneUnbonding_Status[HostZoneUnbonding_Status["EXIT_TRANSFER_IN_PROGRESS"] = 4] = "EXIT_TRANSFER_IN_PROGRESS";
    /** CLAIMABLE - transfer success */
    HostZoneUnbonding_Status[HostZoneUnbonding_Status["CLAIMABLE"] = 2] = "CLAIMABLE";
    HostZoneUnbonding_Status[HostZoneUnbonding_Status["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(HostZoneUnbonding_Status = exports.HostZoneUnbonding_Status || (exports.HostZoneUnbonding_Status = {}));
function hostZoneUnbonding_StatusFromJSON(object) {
    switch (object) {
        case 0:
        case "UNBONDING_QUEUE":
            return HostZoneUnbonding_Status.UNBONDING_QUEUE;
        case 3:
        case "UNBONDING_IN_PROGRESS":
            return HostZoneUnbonding_Status.UNBONDING_IN_PROGRESS;
        case 1:
        case "EXIT_TRANSFER_QUEUE":
            return HostZoneUnbonding_Status.EXIT_TRANSFER_QUEUE;
        case 4:
        case "EXIT_TRANSFER_IN_PROGRESS":
            return HostZoneUnbonding_Status.EXIT_TRANSFER_IN_PROGRESS;
        case 2:
        case "CLAIMABLE":
            return HostZoneUnbonding_Status.CLAIMABLE;
        case -1:
        case "UNRECOGNIZED":
        default:
            return HostZoneUnbonding_Status.UNRECOGNIZED;
    }
}
exports.hostZoneUnbonding_StatusFromJSON = hostZoneUnbonding_StatusFromJSON;
function hostZoneUnbonding_StatusToJSON(object) {
    switch (object) {
        case HostZoneUnbonding_Status.UNBONDING_QUEUE:
            return "UNBONDING_QUEUE";
        case HostZoneUnbonding_Status.UNBONDING_IN_PROGRESS:
            return "UNBONDING_IN_PROGRESS";
        case HostZoneUnbonding_Status.EXIT_TRANSFER_QUEUE:
            return "EXIT_TRANSFER_QUEUE";
        case HostZoneUnbonding_Status.EXIT_TRANSFER_IN_PROGRESS:
            return "EXIT_TRANSFER_IN_PROGRESS";
        case HostZoneUnbonding_Status.CLAIMABLE:
            return "CLAIMABLE";
        default:
            return "UNKNOWN";
    }
}
exports.hostZoneUnbonding_StatusToJSON = hostZoneUnbonding_StatusToJSON;
const baseUserRedemptionRecord = {
    id: "",
    sender: "",
    receiver: "",
    amount: "",
    denom: "",
    hostZoneId: "",
    epochNumber: long_1.default.UZERO,
    claimIsPending: false,
};
exports.UserRedemptionRecord = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.sender !== "") {
            writer.uint32(18).string(message.sender);
        }
        if (message.receiver !== "") {
            writer.uint32(26).string(message.receiver);
        }
        if (message.amount !== "") {
            writer.uint32(34).string(message.amount);
        }
        if (message.denom !== "") {
            writer.uint32(42).string(message.denom);
        }
        if (message.hostZoneId !== "") {
            writer.uint32(50).string(message.hostZoneId);
        }
        if (!message.epochNumber.isZero()) {
            writer.uint32(56).uint64(message.epochNumber);
        }
        if (message.claimIsPending === true) {
            writer.uint32(64).bool(message.claimIsPending);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseUserRedemptionRecord);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.sender = reader.string();
                    break;
                case 3:
                    message.receiver = reader.string();
                    break;
                case 4:
                    message.amount = reader.string();
                    break;
                case 5:
                    message.denom = reader.string();
                    break;
                case 6:
                    message.hostZoneId = reader.string();
                    break;
                case 7:
                    message.epochNumber = reader.uint64();
                    break;
                case 8:
                    message.claimIsPending = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseUserRedemptionRecord);
        if (object.id !== undefined && object.id !== null) {
            message.id = String(object.id);
        }
        else {
            message.id = "";
        }
        if (object.sender !== undefined && object.sender !== null) {
            message.sender = String(object.sender);
        }
        else {
            message.sender = "";
        }
        if (object.receiver !== undefined && object.receiver !== null) {
            message.receiver = String(object.receiver);
        }
        else {
            message.receiver = "";
        }
        if (object.amount !== undefined && object.amount !== null) {
            message.amount = String(object.amount);
        }
        else {
            message.amount = "";
        }
        if (object.denom !== undefined && object.denom !== null) {
            message.denom = String(object.denom);
        }
        else {
            message.denom = "";
        }
        if (object.hostZoneId !== undefined && object.hostZoneId !== null) {
            message.hostZoneId = String(object.hostZoneId);
        }
        else {
            message.hostZoneId = "";
        }
        if (object.epochNumber !== undefined && object.epochNumber !== null) {
            message.epochNumber = long_1.default.fromString(object.epochNumber);
        }
        else {
            message.epochNumber = long_1.default.UZERO;
        }
        if (object.claimIsPending !== undefined && object.claimIsPending !== null) {
            message.claimIsPending = Boolean(object.claimIsPending);
        }
        else {
            message.claimIsPending = false;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.sender !== undefined && (obj.sender = message.sender);
        message.receiver !== undefined && (obj.receiver = message.receiver);
        message.amount !== undefined && (obj.amount = message.amount);
        message.denom !== undefined && (obj.denom = message.denom);
        message.hostZoneId !== undefined && (obj.hostZoneId = message.hostZoneId);
        message.epochNumber !== undefined && (obj.epochNumber = (message.epochNumber || long_1.default.UZERO).toString());
        message.claimIsPending !== undefined && (obj.claimIsPending = message.claimIsPending);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseUserRedemptionRecord);
        if (object.id !== undefined && object.id !== null) {
            message.id = object.id;
        }
        else {
            message.id = "";
        }
        if (object.sender !== undefined && object.sender !== null) {
            message.sender = object.sender;
        }
        else {
            message.sender = "";
        }
        if (object.receiver !== undefined && object.receiver !== null) {
            message.receiver = object.receiver;
        }
        else {
            message.receiver = "";
        }
        if (object.amount !== undefined && object.amount !== null) {
            message.amount = object.amount;
        }
        else {
            message.amount = "";
        }
        if (object.denom !== undefined && object.denom !== null) {
            message.denom = object.denom;
        }
        else {
            message.denom = "";
        }
        if (object.hostZoneId !== undefined && object.hostZoneId !== null) {
            message.hostZoneId = object.hostZoneId;
        }
        else {
            message.hostZoneId = "";
        }
        if (object.epochNumber !== undefined && object.epochNumber !== null) {
            message.epochNumber = object.epochNumber;
        }
        else {
            message.epochNumber = long_1.default.UZERO;
        }
        if (object.claimIsPending !== undefined && object.claimIsPending !== null) {
            message.claimIsPending = object.claimIsPending;
        }
        else {
            message.claimIsPending = false;
        }
        return message;
    },
};
const baseParams = {};
exports.Params = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseParams);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        const message = Object.assign({}, baseParams);
        return message;
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = Object.assign({}, baseParams);
        return message;
    },
};
const baseRecordsPacketData = {};
exports.RecordsPacketData = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.noData !== undefined) {
            exports.NoData.encode(message.noData, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRecordsPacketData);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.noData = exports.NoData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseRecordsPacketData);
        if (object.noData !== undefined && object.noData !== null) {
            message.noData = exports.NoData.fromJSON(object.noData);
        }
        else {
            message.noData = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.noData !== undefined && (obj.noData = message.noData ? exports.NoData.toJSON(message.noData) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseRecordsPacketData);
        if (object.noData !== undefined && object.noData !== null) {
            message.noData = exports.NoData.fromPartial(object.noData);
        }
        else {
            message.noData = undefined;
        }
        return message;
    },
};
const baseNoData = {};
exports.NoData = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseNoData);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        const message = Object.assign({}, baseNoData);
        return message;
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = Object.assign({}, baseNoData);
        return message;
    },
};
const baseDepositRecord = {
    id: long_1.default.UZERO,
    amount: "",
    denom: "",
    hostZoneId: "",
    status: 0,
    depositEpochNumber: long_1.default.UZERO,
    source: 0,
};
exports.DepositRecord = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.id.isZero()) {
            writer.uint32(8).uint64(message.id);
        }
        if (message.amount !== "") {
            writer.uint32(18).string(message.amount);
        }
        if (message.denom !== "") {
            writer.uint32(26).string(message.denom);
        }
        if (message.hostZoneId !== "") {
            writer.uint32(34).string(message.hostZoneId);
        }
        if (message.status !== 0) {
            writer.uint32(48).int32(message.status);
        }
        if (!message.depositEpochNumber.isZero()) {
            writer.uint32(56).uint64(message.depositEpochNumber);
        }
        if (message.source !== 0) {
            writer.uint32(64).int32(message.source);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseDepositRecord);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                case 2:
                    message.amount = reader.string();
                    break;
                case 3:
                    message.denom = reader.string();
                    break;
                case 4:
                    message.hostZoneId = reader.string();
                    break;
                case 6:
                    message.status = reader.int32();
                    break;
                case 7:
                    message.depositEpochNumber = reader.uint64();
                    break;
                case 8:
                    message.source = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseDepositRecord);
        if (object.id !== undefined && object.id !== null) {
            message.id = long_1.default.fromString(object.id);
        }
        else {
            message.id = long_1.default.UZERO;
        }
        if (object.amount !== undefined && object.amount !== null) {
            message.amount = String(object.amount);
        }
        else {
            message.amount = "";
        }
        if (object.denom !== undefined && object.denom !== null) {
            message.denom = String(object.denom);
        }
        else {
            message.denom = "";
        }
        if (object.hostZoneId !== undefined && object.hostZoneId !== null) {
            message.hostZoneId = String(object.hostZoneId);
        }
        else {
            message.hostZoneId = "";
        }
        if (object.status !== undefined && object.status !== null) {
            message.status = depositRecord_StatusFromJSON(object.status);
        }
        else {
            message.status = 0;
        }
        if (object.depositEpochNumber !== undefined && object.depositEpochNumber !== null) {
            message.depositEpochNumber = long_1.default.fromString(object.depositEpochNumber);
        }
        else {
            message.depositEpochNumber = long_1.default.UZERO;
        }
        if (object.source !== undefined && object.source !== null) {
            message.source = depositRecord_SourceFromJSON(object.source);
        }
        else {
            message.source = 0;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = (message.id || long_1.default.UZERO).toString());
        message.amount !== undefined && (obj.amount = message.amount);
        message.denom !== undefined && (obj.denom = message.denom);
        message.hostZoneId !== undefined && (obj.hostZoneId = message.hostZoneId);
        message.status !== undefined && (obj.status = depositRecord_StatusToJSON(message.status));
        message.depositEpochNumber !== undefined &&
            (obj.depositEpochNumber = (message.depositEpochNumber || long_1.default.UZERO).toString());
        message.source !== undefined && (obj.source = depositRecord_SourceToJSON(message.source));
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseDepositRecord);
        if (object.id !== undefined && object.id !== null) {
            message.id = object.id;
        }
        else {
            message.id = long_1.default.UZERO;
        }
        if (object.amount !== undefined && object.amount !== null) {
            message.amount = object.amount;
        }
        else {
            message.amount = "";
        }
        if (object.denom !== undefined && object.denom !== null) {
            message.denom = object.denom;
        }
        else {
            message.denom = "";
        }
        if (object.hostZoneId !== undefined && object.hostZoneId !== null) {
            message.hostZoneId = object.hostZoneId;
        }
        else {
            message.hostZoneId = "";
        }
        if (object.status !== undefined && object.status !== null) {
            message.status = object.status;
        }
        else {
            message.status = 0;
        }
        if (object.depositEpochNumber !== undefined && object.depositEpochNumber !== null) {
            message.depositEpochNumber = object.depositEpochNumber;
        }
        else {
            message.depositEpochNumber = long_1.default.UZERO;
        }
        if (object.source !== undefined && object.source !== null) {
            message.source = object.source;
        }
        else {
            message.source = 0;
        }
        return message;
    },
};
const baseHostZoneUnbonding = {
    stTokenAmount: "",
    nativeTokenAmount: "",
    denom: "",
    hostZoneId: "",
    unbondingTime: long_1.default.UZERO,
    status: 0,
    userRedemptionRecords: "",
};
exports.HostZoneUnbonding = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.stTokenAmount !== "") {
            writer.uint32(10).string(message.stTokenAmount);
        }
        if (message.nativeTokenAmount !== "") {
            writer.uint32(18).string(message.nativeTokenAmount);
        }
        if (message.denom !== "") {
            writer.uint32(26).string(message.denom);
        }
        if (message.hostZoneId !== "") {
            writer.uint32(34).string(message.hostZoneId);
        }
        if (!message.unbondingTime.isZero()) {
            writer.uint32(40).uint64(message.unbondingTime);
        }
        if (message.status !== 0) {
            writer.uint32(48).int32(message.status);
        }
        for (const v of message.userRedemptionRecords) {
            writer.uint32(58).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseHostZoneUnbonding);
        message.userRedemptionRecords = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.stTokenAmount = reader.string();
                    break;
                case 2:
                    message.nativeTokenAmount = reader.string();
                    break;
                case 3:
                    message.denom = reader.string();
                    break;
                case 4:
                    message.hostZoneId = reader.string();
                    break;
                case 5:
                    message.unbondingTime = reader.uint64();
                    break;
                case 6:
                    message.status = reader.int32();
                    break;
                case 7:
                    message.userRedemptionRecords.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseHostZoneUnbonding);
        message.userRedemptionRecords = [];
        if (object.stTokenAmount !== undefined && object.stTokenAmount !== null) {
            message.stTokenAmount = String(object.stTokenAmount);
        }
        else {
            message.stTokenAmount = "";
        }
        if (object.nativeTokenAmount !== undefined && object.nativeTokenAmount !== null) {
            message.nativeTokenAmount = String(object.nativeTokenAmount);
        }
        else {
            message.nativeTokenAmount = "";
        }
        if (object.denom !== undefined && object.denom !== null) {
            message.denom = String(object.denom);
        }
        else {
            message.denom = "";
        }
        if (object.hostZoneId !== undefined && object.hostZoneId !== null) {
            message.hostZoneId = String(object.hostZoneId);
        }
        else {
            message.hostZoneId = "";
        }
        if (object.unbondingTime !== undefined && object.unbondingTime !== null) {
            message.unbondingTime = long_1.default.fromString(object.unbondingTime);
        }
        else {
            message.unbondingTime = long_1.default.UZERO;
        }
        if (object.status !== undefined && object.status !== null) {
            message.status = hostZoneUnbonding_StatusFromJSON(object.status);
        }
        else {
            message.status = 0;
        }
        if (object.userRedemptionRecords !== undefined && object.userRedemptionRecords !== null) {
            for (const e of object.userRedemptionRecords) {
                message.userRedemptionRecords.push(String(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.stTokenAmount !== undefined && (obj.stTokenAmount = message.stTokenAmount);
        message.nativeTokenAmount !== undefined && (obj.nativeTokenAmount = message.nativeTokenAmount);
        message.denom !== undefined && (obj.denom = message.denom);
        message.hostZoneId !== undefined && (obj.hostZoneId = message.hostZoneId);
        message.unbondingTime !== undefined &&
            (obj.unbondingTime = (message.unbondingTime || long_1.default.UZERO).toString());
        message.status !== undefined && (obj.status = hostZoneUnbonding_StatusToJSON(message.status));
        if (message.userRedemptionRecords) {
            obj.userRedemptionRecords = message.userRedemptionRecords.map((e) => e);
        }
        else {
            obj.userRedemptionRecords = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseHostZoneUnbonding);
        message.userRedemptionRecords = [];
        if (object.stTokenAmount !== undefined && object.stTokenAmount !== null) {
            message.stTokenAmount = object.stTokenAmount;
        }
        else {
            message.stTokenAmount = "";
        }
        if (object.nativeTokenAmount !== undefined && object.nativeTokenAmount !== null) {
            message.nativeTokenAmount = object.nativeTokenAmount;
        }
        else {
            message.nativeTokenAmount = "";
        }
        if (object.denom !== undefined && object.denom !== null) {
            message.denom = object.denom;
        }
        else {
            message.denom = "";
        }
        if (object.hostZoneId !== undefined && object.hostZoneId !== null) {
            message.hostZoneId = object.hostZoneId;
        }
        else {
            message.hostZoneId = "";
        }
        if (object.unbondingTime !== undefined && object.unbondingTime !== null) {
            message.unbondingTime = object.unbondingTime;
        }
        else {
            message.unbondingTime = long_1.default.UZERO;
        }
        if (object.status !== undefined && object.status !== null) {
            message.status = object.status;
        }
        else {
            message.status = 0;
        }
        if (object.userRedemptionRecords !== undefined && object.userRedemptionRecords !== null) {
            for (const e of object.userRedemptionRecords) {
                message.userRedemptionRecords.push(e);
            }
        }
        return message;
    },
};
const baseEpochUnbondingRecord = { epochNumber: long_1.default.UZERO };
exports.EpochUnbondingRecord = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.epochNumber.isZero()) {
            writer.uint32(8).uint64(message.epochNumber);
        }
        for (const v of message.hostZoneUnbondings) {
            exports.HostZoneUnbonding.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseEpochUnbondingRecord);
        message.hostZoneUnbondings = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.epochNumber = reader.uint64();
                    break;
                case 3:
                    message.hostZoneUnbondings.push(exports.HostZoneUnbonding.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseEpochUnbondingRecord);
        message.hostZoneUnbondings = [];
        if (object.epochNumber !== undefined && object.epochNumber !== null) {
            message.epochNumber = long_1.default.fromString(object.epochNumber);
        }
        else {
            message.epochNumber = long_1.default.UZERO;
        }
        if (object.hostZoneUnbondings !== undefined && object.hostZoneUnbondings !== null) {
            for (const e of object.hostZoneUnbondings) {
                message.hostZoneUnbondings.push(exports.HostZoneUnbonding.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.epochNumber !== undefined && (obj.epochNumber = (message.epochNumber || long_1.default.UZERO).toString());
        if (message.hostZoneUnbondings) {
            obj.hostZoneUnbondings = message.hostZoneUnbondings.map((e) => e ? exports.HostZoneUnbonding.toJSON(e) : undefined);
        }
        else {
            obj.hostZoneUnbondings = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseEpochUnbondingRecord);
        message.hostZoneUnbondings = [];
        if (object.epochNumber !== undefined && object.epochNumber !== null) {
            message.epochNumber = object.epochNumber;
        }
        else {
            message.epochNumber = long_1.default.UZERO;
        }
        if (object.hostZoneUnbondings !== undefined && object.hostZoneUnbondings !== null) {
            for (const e of object.hostZoneUnbondings) {
                message.hostZoneUnbondings.push(exports.HostZoneUnbonding.fromPartial(e));
            }
        }
        return message;
    },
};
const baseGenesisState = {
    portId: "",
    userRedemptionRecordCount: long_1.default.UZERO,
    depositRecordCount: long_1.default.UZERO,
};
exports.GenesisState = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.params !== undefined) {
            exports.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        if (message.portId !== "") {
            writer.uint32(18).string(message.portId);
        }
        for (const v of message.userRedemptionRecordList) {
            exports.UserRedemptionRecord.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (!message.userRedemptionRecordCount.isZero()) {
            writer.uint32(32).uint64(message.userRedemptionRecordCount);
        }
        for (const v of message.epochUnbondingRecordList) {
            exports.EpochUnbondingRecord.encode(v, writer.uint32(42).fork()).ldelim();
        }
        for (const v of message.depositRecordList) {
            exports.DepositRecord.encode(v, writer.uint32(58).fork()).ldelim();
        }
        if (!message.depositRecordCount.isZero()) {
            writer.uint32(64).uint64(message.depositRecordCount);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseGenesisState);
        message.userRedemptionRecordList = [];
        message.epochUnbondingRecordList = [];
        message.depositRecordList = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.params = exports.Params.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.portId = reader.string();
                    break;
                case 3:
                    message.userRedemptionRecordList.push(exports.UserRedemptionRecord.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.userRedemptionRecordCount = reader.uint64();
                    break;
                case 5:
                    message.epochUnbondingRecordList.push(exports.EpochUnbondingRecord.decode(reader, reader.uint32()));
                    break;
                case 7:
                    message.depositRecordList.push(exports.DepositRecord.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.depositRecordCount = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseGenesisState);
        message.userRedemptionRecordList = [];
        message.epochUnbondingRecordList = [];
        message.depositRecordList = [];
        if (object.params !== undefined && object.params !== null) {
            message.params = exports.Params.fromJSON(object.params);
        }
        else {
            message.params = undefined;
        }
        if (object.portId !== undefined && object.portId !== null) {
            message.portId = String(object.portId);
        }
        else {
            message.portId = "";
        }
        if (object.userRedemptionRecordList !== undefined && object.userRedemptionRecordList !== null) {
            for (const e of object.userRedemptionRecordList) {
                message.userRedemptionRecordList.push(exports.UserRedemptionRecord.fromJSON(e));
            }
        }
        if (object.userRedemptionRecordCount !== undefined && object.userRedemptionRecordCount !== null) {
            message.userRedemptionRecordCount = long_1.default.fromString(object.userRedemptionRecordCount);
        }
        else {
            message.userRedemptionRecordCount = long_1.default.UZERO;
        }
        if (object.epochUnbondingRecordList !== undefined && object.epochUnbondingRecordList !== null) {
            for (const e of object.epochUnbondingRecordList) {
                message.epochUnbondingRecordList.push(exports.EpochUnbondingRecord.fromJSON(e));
            }
        }
        if (object.depositRecordList !== undefined && object.depositRecordList !== null) {
            for (const e of object.depositRecordList) {
                message.depositRecordList.push(exports.DepositRecord.fromJSON(e));
            }
        }
        if (object.depositRecordCount !== undefined && object.depositRecordCount !== null) {
            message.depositRecordCount = long_1.default.fromString(object.depositRecordCount);
        }
        else {
            message.depositRecordCount = long_1.default.UZERO;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.params !== undefined && (obj.params = message.params ? exports.Params.toJSON(message.params) : undefined);
        message.portId !== undefined && (obj.portId = message.portId);
        if (message.userRedemptionRecordList) {
            obj.userRedemptionRecordList = message.userRedemptionRecordList.map((e) => e ? exports.UserRedemptionRecord.toJSON(e) : undefined);
        }
        else {
            obj.userRedemptionRecordList = [];
        }
        message.userRedemptionRecordCount !== undefined &&
            (obj.userRedemptionRecordCount = (message.userRedemptionRecordCount || long_1.default.UZERO).toString());
        if (message.epochUnbondingRecordList) {
            obj.epochUnbondingRecordList = message.epochUnbondingRecordList.map((e) => e ? exports.EpochUnbondingRecord.toJSON(e) : undefined);
        }
        else {
            obj.epochUnbondingRecordList = [];
        }
        if (message.depositRecordList) {
            obj.depositRecordList = message.depositRecordList.map((e) => (e ? exports.DepositRecord.toJSON(e) : undefined));
        }
        else {
            obj.depositRecordList = [];
        }
        message.depositRecordCount !== undefined &&
            (obj.depositRecordCount = (message.depositRecordCount || long_1.default.UZERO).toString());
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseGenesisState);
        message.userRedemptionRecordList = [];
        message.epochUnbondingRecordList = [];
        message.depositRecordList = [];
        if (object.params !== undefined && object.params !== null) {
            message.params = exports.Params.fromPartial(object.params);
        }
        else {
            message.params = undefined;
        }
        if (object.portId !== undefined && object.portId !== null) {
            message.portId = object.portId;
        }
        else {
            message.portId = "";
        }
        if (object.userRedemptionRecordList !== undefined && object.userRedemptionRecordList !== null) {
            for (const e of object.userRedemptionRecordList) {
                message.userRedemptionRecordList.push(exports.UserRedemptionRecord.fromPartial(e));
            }
        }
        if (object.userRedemptionRecordCount !== undefined && object.userRedemptionRecordCount !== null) {
            message.userRedemptionRecordCount = object.userRedemptionRecordCount;
        }
        else {
            message.userRedemptionRecordCount = long_1.default.UZERO;
        }
        if (object.epochUnbondingRecordList !== undefined && object.epochUnbondingRecordList !== null) {
            for (const e of object.epochUnbondingRecordList) {
                message.epochUnbondingRecordList.push(exports.EpochUnbondingRecord.fromPartial(e));
            }
        }
        if (object.depositRecordList !== undefined && object.depositRecordList !== null) {
            for (const e of object.depositRecordList) {
                message.depositRecordList.push(exports.DepositRecord.fromPartial(e));
            }
        }
        if (object.depositRecordCount !== undefined && object.depositRecordCount !== null) {
            message.depositRecordCount = object.depositRecordCount;
        }
        else {
            message.depositRecordCount = long_1.default.UZERO;
        }
        return message;
    },
};
class MsgClientImpl {
    constructor(rpc) {
        this.rpc = rpc;
    }
}
exports.MsgClientImpl = MsgClientImpl;
exports.MsgDesc = {
    serviceName: "stride.records.Msg",
};
class GrpcWebImpl {
    constructor(host, options) {
        this.host = host;
        this.options = options;
    }
    unary(methodDesc, _request, metadata) {
        var _a;
        const request = Object.assign(Object.assign({}, _request), methodDesc.requestType);
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new browser_headers_1.BrowserHeaders(Object.assign(Object.assign({}, (_a = this.options) === null || _a === void 0 ? void 0 : _a.metadata.headersMap), metadata === null || metadata === void 0 ? void 0 : metadata.headersMap))
            : metadata || this.options.metadata;
        return new Promise((resolve, reject) => {
            grpc_web_1.grpc.unary(methodDesc, {
                request,
                host: this.host,
                metadata: maybeCombinedMetadata,
                transport: this.options.transport,
                debug: this.options.debug,
                onEnd: function (response) {
                    if (response.status === grpc_web_1.grpc.Code.OK) {
                        resolve(response.message);
                    }
                    else {
                        const err = new Error(response.statusMessage);
                        err.code = response.status;
                        err.metadata = response.trailers;
                        reject(err);
                    }
                },
            });
        });
    }
}
exports.GrpcWebImpl = GrpcWebImpl;
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
//# sourceMappingURL=genesis.js.map