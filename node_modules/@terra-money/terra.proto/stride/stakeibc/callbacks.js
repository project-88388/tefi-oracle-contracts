"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RebalanceCallback = exports.Rebalancing = exports.RedemptionCallback = exports.UndelegateCallback = exports.ReinvestCallback = exports.ClaimCallback = exports.DelegateCallback = exports.SplitDelegation = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const coin_1 = require("../../cosmos/base/v1beta1/coin");
exports.protobufPackage = "stride.stakeibc";
const baseSplitDelegation = { validator: "", amount: "" };
exports.SplitDelegation = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validator !== "") {
            writer.uint32(10).string(message.validator);
        }
        if (message.amount !== "") {
            writer.uint32(18).string(message.amount);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSplitDelegation);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.validator = reader.string();
                    break;
                case 2:
                    message.amount = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseSplitDelegation);
        if (object.validator !== undefined && object.validator !== null) {
            message.validator = String(object.validator);
        }
        else {
            message.validator = "";
        }
        if (object.amount !== undefined && object.amount !== null) {
            message.amount = String(object.amount);
        }
        else {
            message.amount = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.validator !== undefined && (obj.validator = message.validator);
        message.amount !== undefined && (obj.amount = message.amount);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseSplitDelegation);
        if (object.validator !== undefined && object.validator !== null) {
            message.validator = object.validator;
        }
        else {
            message.validator = "";
        }
        if (object.amount !== undefined && object.amount !== null) {
            message.amount = object.amount;
        }
        else {
            message.amount = "";
        }
        return message;
    },
};
const baseDelegateCallback = { hostZoneId: "", depositRecordId: long_1.default.UZERO };
exports.DelegateCallback = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.hostZoneId !== "") {
            writer.uint32(10).string(message.hostZoneId);
        }
        if (!message.depositRecordId.isZero()) {
            writer.uint32(16).uint64(message.depositRecordId);
        }
        for (const v of message.splitDelegations) {
            exports.SplitDelegation.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseDelegateCallback);
        message.splitDelegations = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.hostZoneId = reader.string();
                    break;
                case 2:
                    message.depositRecordId = reader.uint64();
                    break;
                case 3:
                    message.splitDelegations.push(exports.SplitDelegation.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseDelegateCallback);
        message.splitDelegations = [];
        if (object.hostZoneId !== undefined && object.hostZoneId !== null) {
            message.hostZoneId = String(object.hostZoneId);
        }
        else {
            message.hostZoneId = "";
        }
        if (object.depositRecordId !== undefined && object.depositRecordId !== null) {
            message.depositRecordId = long_1.default.fromString(object.depositRecordId);
        }
        else {
            message.depositRecordId = long_1.default.UZERO;
        }
        if (object.splitDelegations !== undefined && object.splitDelegations !== null) {
            for (const e of object.splitDelegations) {
                message.splitDelegations.push(exports.SplitDelegation.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.hostZoneId !== undefined && (obj.hostZoneId = message.hostZoneId);
        message.depositRecordId !== undefined &&
            (obj.depositRecordId = (message.depositRecordId || long_1.default.UZERO).toString());
        if (message.splitDelegations) {
            obj.splitDelegations = message.splitDelegations.map((e) => (e ? exports.SplitDelegation.toJSON(e) : undefined));
        }
        else {
            obj.splitDelegations = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseDelegateCallback);
        message.splitDelegations = [];
        if (object.hostZoneId !== undefined && object.hostZoneId !== null) {
            message.hostZoneId = object.hostZoneId;
        }
        else {
            message.hostZoneId = "";
        }
        if (object.depositRecordId !== undefined && object.depositRecordId !== null) {
            message.depositRecordId = object.depositRecordId;
        }
        else {
            message.depositRecordId = long_1.default.UZERO;
        }
        if (object.splitDelegations !== undefined && object.splitDelegations !== null) {
            for (const e of object.splitDelegations) {
                message.splitDelegations.push(exports.SplitDelegation.fromPartial(e));
            }
        }
        return message;
    },
};
const baseClaimCallback = { userRedemptionRecordId: "", chainId: "", epochNumber: long_1.default.UZERO };
exports.ClaimCallback = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.userRedemptionRecordId !== "") {
            writer.uint32(10).string(message.userRedemptionRecordId);
        }
        if (message.chainId !== "") {
            writer.uint32(18).string(message.chainId);
        }
        if (!message.epochNumber.isZero()) {
            writer.uint32(24).uint64(message.epochNumber);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseClaimCallback);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.userRedemptionRecordId = reader.string();
                    break;
                case 2:
                    message.chainId = reader.string();
                    break;
                case 3:
                    message.epochNumber = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseClaimCallback);
        if (object.userRedemptionRecordId !== undefined && object.userRedemptionRecordId !== null) {
            message.userRedemptionRecordId = String(object.userRedemptionRecordId);
        }
        else {
            message.userRedemptionRecordId = "";
        }
        if (object.chainId !== undefined && object.chainId !== null) {
            message.chainId = String(object.chainId);
        }
        else {
            message.chainId = "";
        }
        if (object.epochNumber !== undefined && object.epochNumber !== null) {
            message.epochNumber = long_1.default.fromString(object.epochNumber);
        }
        else {
            message.epochNumber = long_1.default.UZERO;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.userRedemptionRecordId !== undefined &&
            (obj.userRedemptionRecordId = message.userRedemptionRecordId);
        message.chainId !== undefined && (obj.chainId = message.chainId);
        message.epochNumber !== undefined && (obj.epochNumber = (message.epochNumber || long_1.default.UZERO).toString());
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseClaimCallback);
        if (object.userRedemptionRecordId !== undefined && object.userRedemptionRecordId !== null) {
            message.userRedemptionRecordId = object.userRedemptionRecordId;
        }
        else {
            message.userRedemptionRecordId = "";
        }
        if (object.chainId !== undefined && object.chainId !== null) {
            message.chainId = object.chainId;
        }
        else {
            message.chainId = "";
        }
        if (object.epochNumber !== undefined && object.epochNumber !== null) {
            message.epochNumber = object.epochNumber;
        }
        else {
            message.epochNumber = long_1.default.UZERO;
        }
        return message;
    },
};
const baseReinvestCallback = { hostZoneId: "" };
exports.ReinvestCallback = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.reinvestAmount !== undefined) {
            coin_1.Coin.encode(message.reinvestAmount, writer.uint32(10).fork()).ldelim();
        }
        if (message.hostZoneId !== "") {
            writer.uint32(26).string(message.hostZoneId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseReinvestCallback);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.reinvestAmount = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.hostZoneId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseReinvestCallback);
        if (object.reinvestAmount !== undefined && object.reinvestAmount !== null) {
            message.reinvestAmount = coin_1.Coin.fromJSON(object.reinvestAmount);
        }
        else {
            message.reinvestAmount = undefined;
        }
        if (object.hostZoneId !== undefined && object.hostZoneId !== null) {
            message.hostZoneId = String(object.hostZoneId);
        }
        else {
            message.hostZoneId = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.reinvestAmount !== undefined &&
            (obj.reinvestAmount = message.reinvestAmount ? coin_1.Coin.toJSON(message.reinvestAmount) : undefined);
        message.hostZoneId !== undefined && (obj.hostZoneId = message.hostZoneId);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseReinvestCallback);
        if (object.reinvestAmount !== undefined && object.reinvestAmount !== null) {
            message.reinvestAmount = coin_1.Coin.fromPartial(object.reinvestAmount);
        }
        else {
            message.reinvestAmount = undefined;
        }
        if (object.hostZoneId !== undefined && object.hostZoneId !== null) {
            message.hostZoneId = object.hostZoneId;
        }
        else {
            message.hostZoneId = "";
        }
        return message;
    },
};
const baseUndelegateCallback = { hostZoneId: "", epochUnbondingRecordIds: long_1.default.UZERO };
exports.UndelegateCallback = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.hostZoneId !== "") {
            writer.uint32(10).string(message.hostZoneId);
        }
        for (const v of message.splitDelegations) {
            exports.SplitDelegation.encode(v, writer.uint32(18).fork()).ldelim();
        }
        writer.uint32(26).fork();
        for (const v of message.epochUnbondingRecordIds) {
            writer.uint64(v);
        }
        writer.ldelim();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseUndelegateCallback);
        message.splitDelegations = [];
        message.epochUnbondingRecordIds = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.hostZoneId = reader.string();
                    break;
                case 2:
                    message.splitDelegations.push(exports.SplitDelegation.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.epochUnbondingRecordIds.push(reader.uint64());
                        }
                    }
                    else {
                        message.epochUnbondingRecordIds.push(reader.uint64());
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseUndelegateCallback);
        message.splitDelegations = [];
        message.epochUnbondingRecordIds = [];
        if (object.hostZoneId !== undefined && object.hostZoneId !== null) {
            message.hostZoneId = String(object.hostZoneId);
        }
        else {
            message.hostZoneId = "";
        }
        if (object.splitDelegations !== undefined && object.splitDelegations !== null) {
            for (const e of object.splitDelegations) {
                message.splitDelegations.push(exports.SplitDelegation.fromJSON(e));
            }
        }
        if (object.epochUnbondingRecordIds !== undefined && object.epochUnbondingRecordIds !== null) {
            for (const e of object.epochUnbondingRecordIds) {
                message.epochUnbondingRecordIds.push(long_1.default.fromString(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.hostZoneId !== undefined && (obj.hostZoneId = message.hostZoneId);
        if (message.splitDelegations) {
            obj.splitDelegations = message.splitDelegations.map((e) => (e ? exports.SplitDelegation.toJSON(e) : undefined));
        }
        else {
            obj.splitDelegations = [];
        }
        if (message.epochUnbondingRecordIds) {
            obj.epochUnbondingRecordIds = message.epochUnbondingRecordIds.map((e) => (e || long_1.default.UZERO).toString());
        }
        else {
            obj.epochUnbondingRecordIds = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseUndelegateCallback);
        message.splitDelegations = [];
        message.epochUnbondingRecordIds = [];
        if (object.hostZoneId !== undefined && object.hostZoneId !== null) {
            message.hostZoneId = object.hostZoneId;
        }
        else {
            message.hostZoneId = "";
        }
        if (object.splitDelegations !== undefined && object.splitDelegations !== null) {
            for (const e of object.splitDelegations) {
                message.splitDelegations.push(exports.SplitDelegation.fromPartial(e));
            }
        }
        if (object.epochUnbondingRecordIds !== undefined && object.epochUnbondingRecordIds !== null) {
            for (const e of object.epochUnbondingRecordIds) {
                message.epochUnbondingRecordIds.push(e);
            }
        }
        return message;
    },
};
const baseRedemptionCallback = { hostZoneId: "", epochUnbondingRecordIds: long_1.default.UZERO };
exports.RedemptionCallback = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.hostZoneId !== "") {
            writer.uint32(10).string(message.hostZoneId);
        }
        writer.uint32(18).fork();
        for (const v of message.epochUnbondingRecordIds) {
            writer.uint64(v);
        }
        writer.ldelim();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRedemptionCallback);
        message.epochUnbondingRecordIds = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.hostZoneId = reader.string();
                    break;
                case 2:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.epochUnbondingRecordIds.push(reader.uint64());
                        }
                    }
                    else {
                        message.epochUnbondingRecordIds.push(reader.uint64());
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseRedemptionCallback);
        message.epochUnbondingRecordIds = [];
        if (object.hostZoneId !== undefined && object.hostZoneId !== null) {
            message.hostZoneId = String(object.hostZoneId);
        }
        else {
            message.hostZoneId = "";
        }
        if (object.epochUnbondingRecordIds !== undefined && object.epochUnbondingRecordIds !== null) {
            for (const e of object.epochUnbondingRecordIds) {
                message.epochUnbondingRecordIds.push(long_1.default.fromString(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.hostZoneId !== undefined && (obj.hostZoneId = message.hostZoneId);
        if (message.epochUnbondingRecordIds) {
            obj.epochUnbondingRecordIds = message.epochUnbondingRecordIds.map((e) => (e || long_1.default.UZERO).toString());
        }
        else {
            obj.epochUnbondingRecordIds = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseRedemptionCallback);
        message.epochUnbondingRecordIds = [];
        if (object.hostZoneId !== undefined && object.hostZoneId !== null) {
            message.hostZoneId = object.hostZoneId;
        }
        else {
            message.hostZoneId = "";
        }
        if (object.epochUnbondingRecordIds !== undefined && object.epochUnbondingRecordIds !== null) {
            for (const e of object.epochUnbondingRecordIds) {
                message.epochUnbondingRecordIds.push(e);
            }
        }
        return message;
    },
};
const baseRebalancing = { srcValidator: "", dstValidator: "", amt: "" };
exports.Rebalancing = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.srcValidator !== "") {
            writer.uint32(10).string(message.srcValidator);
        }
        if (message.dstValidator !== "") {
            writer.uint32(18).string(message.dstValidator);
        }
        if (message.amt !== "") {
            writer.uint32(26).string(message.amt);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRebalancing);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.srcValidator = reader.string();
                    break;
                case 2:
                    message.dstValidator = reader.string();
                    break;
                case 3:
                    message.amt = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseRebalancing);
        if (object.srcValidator !== undefined && object.srcValidator !== null) {
            message.srcValidator = String(object.srcValidator);
        }
        else {
            message.srcValidator = "";
        }
        if (object.dstValidator !== undefined && object.dstValidator !== null) {
            message.dstValidator = String(object.dstValidator);
        }
        else {
            message.dstValidator = "";
        }
        if (object.amt !== undefined && object.amt !== null) {
            message.amt = String(object.amt);
        }
        else {
            message.amt = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.srcValidator !== undefined && (obj.srcValidator = message.srcValidator);
        message.dstValidator !== undefined && (obj.dstValidator = message.dstValidator);
        message.amt !== undefined && (obj.amt = message.amt);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseRebalancing);
        if (object.srcValidator !== undefined && object.srcValidator !== null) {
            message.srcValidator = object.srcValidator;
        }
        else {
            message.srcValidator = "";
        }
        if (object.dstValidator !== undefined && object.dstValidator !== null) {
            message.dstValidator = object.dstValidator;
        }
        else {
            message.dstValidator = "";
        }
        if (object.amt !== undefined && object.amt !== null) {
            message.amt = object.amt;
        }
        else {
            message.amt = "";
        }
        return message;
    },
};
const baseRebalanceCallback = { hostZoneId: "" };
exports.RebalanceCallback = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.hostZoneId !== "") {
            writer.uint32(10).string(message.hostZoneId);
        }
        for (const v of message.rebalancings) {
            exports.Rebalancing.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRebalanceCallback);
        message.rebalancings = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.hostZoneId = reader.string();
                    break;
                case 2:
                    message.rebalancings.push(exports.Rebalancing.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseRebalanceCallback);
        message.rebalancings = [];
        if (object.hostZoneId !== undefined && object.hostZoneId !== null) {
            message.hostZoneId = String(object.hostZoneId);
        }
        else {
            message.hostZoneId = "";
        }
        if (object.rebalancings !== undefined && object.rebalancings !== null) {
            for (const e of object.rebalancings) {
                message.rebalancings.push(exports.Rebalancing.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.hostZoneId !== undefined && (obj.hostZoneId = message.hostZoneId);
        if (message.rebalancings) {
            obj.rebalancings = message.rebalancings.map((e) => (e ? exports.Rebalancing.toJSON(e) : undefined));
        }
        else {
            obj.rebalancings = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseRebalanceCallback);
        message.rebalancings = [];
        if (object.hostZoneId !== undefined && object.hostZoneId !== null) {
            message.hostZoneId = object.hostZoneId;
        }
        else {
            message.hostZoneId = "";
        }
        if (object.rebalancings !== undefined && object.rebalancings !== null) {
            for (const e of object.rebalancings) {
                message.rebalancings.push(exports.Rebalancing.fromPartial(e));
            }
        }
        return message;
    },
};
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
//# sourceMappingURL=callbacks.js.map