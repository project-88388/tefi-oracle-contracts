"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GrpcWebImpl = exports.MsgClearBalanceDesc = exports.MsgUpdateValidatorSharesExchRateDesc = exports.MsgRestoreInterchainAccountDesc = exports.MsgDeleteValidatorDesc = exports.MsgChangeValidatorWeightDesc = exports.MsgAddValidatorDesc = exports.MsgRebalanceValidatorsDesc = exports.MsgClaimUndelegatedTokensDesc = exports.MsgRegisterHostZoneDesc = exports.MsgRedeemStakeDesc = exports.MsgLiquidStakeDesc = exports.MsgDesc = exports.MsgClientImpl = exports.MsgUpdateValidatorSharesExchRateResponse = exports.MsgUpdateValidatorSharesExchRate = exports.MsgRestoreInterchainAccountResponse = exports.MsgRestoreInterchainAccount = exports.MsgDeleteValidatorResponse = exports.MsgDeleteValidator = exports.MsgChangeValidatorWeightResponse = exports.MsgChangeValidatorWeight = exports.MsgAddValidatorResponse = exports.MsgAddValidator = exports.MsgRebalanceValidatorsResponse = exports.MsgRebalanceValidators = exports.MsgClaimUndelegatedTokensResponse = exports.MsgClaimUndelegatedTokens = exports.MsgRegisterHostZoneResponse = exports.MsgRegisterHostZone = exports.MsgRedeemStakeResponse = exports.MsgRedeemStake = exports.MsgClearBalanceResponse = exports.MsgClearBalance = exports.MsgLiquidStakeResponse = exports.MsgLiquidStake = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const grpc_web_1 = require("@improbable-eng/grpc-web");
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const ica_account_1 = require("../../stride/stakeibc/ica_account");
const browser_headers_1 = require("browser-headers");
exports.protobufPackage = "stride.stakeibc";
const baseMsgLiquidStake = { creator: "", amount: "", hostDenom: "" };
exports.MsgLiquidStake = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.amount !== "") {
            writer.uint32(18).string(message.amount);
        }
        if (message.hostDenom !== "") {
            writer.uint32(26).string(message.hostDenom);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgLiquidStake);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.creator = reader.string();
                    break;
                case 2:
                    message.amount = reader.string();
                    break;
                case 3:
                    message.hostDenom = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseMsgLiquidStake);
        if (object.creator !== undefined && object.creator !== null) {
            message.creator = String(object.creator);
        }
        else {
            message.creator = "";
        }
        if (object.amount !== undefined && object.amount !== null) {
            message.amount = String(object.amount);
        }
        else {
            message.amount = "";
        }
        if (object.hostDenom !== undefined && object.hostDenom !== null) {
            message.hostDenom = String(object.hostDenom);
        }
        else {
            message.hostDenom = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.creator !== undefined && (obj.creator = message.creator);
        message.amount !== undefined && (obj.amount = message.amount);
        message.hostDenom !== undefined && (obj.hostDenom = message.hostDenom);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseMsgLiquidStake);
        if (object.creator !== undefined && object.creator !== null) {
            message.creator = object.creator;
        }
        else {
            message.creator = "";
        }
        if (object.amount !== undefined && object.amount !== null) {
            message.amount = object.amount;
        }
        else {
            message.amount = "";
        }
        if (object.hostDenom !== undefined && object.hostDenom !== null) {
            message.hostDenom = object.hostDenom;
        }
        else {
            message.hostDenom = "";
        }
        return message;
    },
};
const baseMsgLiquidStakeResponse = {};
exports.MsgLiquidStakeResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgLiquidStakeResponse);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        const message = Object.assign({}, baseMsgLiquidStakeResponse);
        return message;
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = Object.assign({}, baseMsgLiquidStakeResponse);
        return message;
    },
};
const baseMsgClearBalance = { creator: "", chainId: "", amount: "", channel: "" };
exports.MsgClearBalance = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.chainId !== "") {
            writer.uint32(18).string(message.chainId);
        }
        if (message.amount !== "") {
            writer.uint32(26).string(message.amount);
        }
        if (message.channel !== "") {
            writer.uint32(34).string(message.channel);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgClearBalance);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.creator = reader.string();
                    break;
                case 2:
                    message.chainId = reader.string();
                    break;
                case 3:
                    message.amount = reader.string();
                    break;
                case 4:
                    message.channel = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseMsgClearBalance);
        if (object.creator !== undefined && object.creator !== null) {
            message.creator = String(object.creator);
        }
        else {
            message.creator = "";
        }
        if (object.chainId !== undefined && object.chainId !== null) {
            message.chainId = String(object.chainId);
        }
        else {
            message.chainId = "";
        }
        if (object.amount !== undefined && object.amount !== null) {
            message.amount = String(object.amount);
        }
        else {
            message.amount = "";
        }
        if (object.channel !== undefined && object.channel !== null) {
            message.channel = String(object.channel);
        }
        else {
            message.channel = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.creator !== undefined && (obj.creator = message.creator);
        message.chainId !== undefined && (obj.chainId = message.chainId);
        message.amount !== undefined && (obj.amount = message.amount);
        message.channel !== undefined && (obj.channel = message.channel);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseMsgClearBalance);
        if (object.creator !== undefined && object.creator !== null) {
            message.creator = object.creator;
        }
        else {
            message.creator = "";
        }
        if (object.chainId !== undefined && object.chainId !== null) {
            message.chainId = object.chainId;
        }
        else {
            message.chainId = "";
        }
        if (object.amount !== undefined && object.amount !== null) {
            message.amount = object.amount;
        }
        else {
            message.amount = "";
        }
        if (object.channel !== undefined && object.channel !== null) {
            message.channel = object.channel;
        }
        else {
            message.channel = "";
        }
        return message;
    },
};
const baseMsgClearBalanceResponse = {};
exports.MsgClearBalanceResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgClearBalanceResponse);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        const message = Object.assign({}, baseMsgClearBalanceResponse);
        return message;
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = Object.assign({}, baseMsgClearBalanceResponse);
        return message;
    },
};
const baseMsgRedeemStake = { creator: "", amount: "", hostZone: "", receiver: "" };
exports.MsgRedeemStake = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.amount !== "") {
            writer.uint32(18).string(message.amount);
        }
        if (message.hostZone !== "") {
            writer.uint32(26).string(message.hostZone);
        }
        if (message.receiver !== "") {
            writer.uint32(34).string(message.receiver);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgRedeemStake);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.creator = reader.string();
                    break;
                case 2:
                    message.amount = reader.string();
                    break;
                case 3:
                    message.hostZone = reader.string();
                    break;
                case 4:
                    message.receiver = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseMsgRedeemStake);
        if (object.creator !== undefined && object.creator !== null) {
            message.creator = String(object.creator);
        }
        else {
            message.creator = "";
        }
        if (object.amount !== undefined && object.amount !== null) {
            message.amount = String(object.amount);
        }
        else {
            message.amount = "";
        }
        if (object.hostZone !== undefined && object.hostZone !== null) {
            message.hostZone = String(object.hostZone);
        }
        else {
            message.hostZone = "";
        }
        if (object.receiver !== undefined && object.receiver !== null) {
            message.receiver = String(object.receiver);
        }
        else {
            message.receiver = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.creator !== undefined && (obj.creator = message.creator);
        message.amount !== undefined && (obj.amount = message.amount);
        message.hostZone !== undefined && (obj.hostZone = message.hostZone);
        message.receiver !== undefined && (obj.receiver = message.receiver);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseMsgRedeemStake);
        if (object.creator !== undefined && object.creator !== null) {
            message.creator = object.creator;
        }
        else {
            message.creator = "";
        }
        if (object.amount !== undefined && object.amount !== null) {
            message.amount = object.amount;
        }
        else {
            message.amount = "";
        }
        if (object.hostZone !== undefined && object.hostZone !== null) {
            message.hostZone = object.hostZone;
        }
        else {
            message.hostZone = "";
        }
        if (object.receiver !== undefined && object.receiver !== null) {
            message.receiver = object.receiver;
        }
        else {
            message.receiver = "";
        }
        return message;
    },
};
const baseMsgRedeemStakeResponse = {};
exports.MsgRedeemStakeResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgRedeemStakeResponse);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        const message = Object.assign({}, baseMsgRedeemStakeResponse);
        return message;
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = Object.assign({}, baseMsgRedeemStakeResponse);
        return message;
    },
};
const baseMsgRegisterHostZone = {
    connectionId: "",
    bech32prefix: "",
    hostDenom: "",
    ibcDenom: "",
    creator: "",
    transferChannelId: "",
    unbondingFrequency: long_1.default.UZERO,
};
exports.MsgRegisterHostZone = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.connectionId !== "") {
            writer.uint32(18).string(message.connectionId);
        }
        if (message.bech32prefix !== "") {
            writer.uint32(98).string(message.bech32prefix);
        }
        if (message.hostDenom !== "") {
            writer.uint32(34).string(message.hostDenom);
        }
        if (message.ibcDenom !== "") {
            writer.uint32(42).string(message.ibcDenom);
        }
        if (message.creator !== "") {
            writer.uint32(50).string(message.creator);
        }
        if (message.transferChannelId !== "") {
            writer.uint32(82).string(message.transferChannelId);
        }
        if (!message.unbondingFrequency.isZero()) {
            writer.uint32(88).uint64(message.unbondingFrequency);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgRegisterHostZone);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.connectionId = reader.string();
                    break;
                case 12:
                    message.bech32prefix = reader.string();
                    break;
                case 4:
                    message.hostDenom = reader.string();
                    break;
                case 5:
                    message.ibcDenom = reader.string();
                    break;
                case 6:
                    message.creator = reader.string();
                    break;
                case 10:
                    message.transferChannelId = reader.string();
                    break;
                case 11:
                    message.unbondingFrequency = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseMsgRegisterHostZone);
        if (object.connectionId !== undefined && object.connectionId !== null) {
            message.connectionId = String(object.connectionId);
        }
        else {
            message.connectionId = "";
        }
        if (object.bech32prefix !== undefined && object.bech32prefix !== null) {
            message.bech32prefix = String(object.bech32prefix);
        }
        else {
            message.bech32prefix = "";
        }
        if (object.hostDenom !== undefined && object.hostDenom !== null) {
            message.hostDenom = String(object.hostDenom);
        }
        else {
            message.hostDenom = "";
        }
        if (object.ibcDenom !== undefined && object.ibcDenom !== null) {
            message.ibcDenom = String(object.ibcDenom);
        }
        else {
            message.ibcDenom = "";
        }
        if (object.creator !== undefined && object.creator !== null) {
            message.creator = String(object.creator);
        }
        else {
            message.creator = "";
        }
        if (object.transferChannelId !== undefined && object.transferChannelId !== null) {
            message.transferChannelId = String(object.transferChannelId);
        }
        else {
            message.transferChannelId = "";
        }
        if (object.unbondingFrequency !== undefined && object.unbondingFrequency !== null) {
            message.unbondingFrequency = long_1.default.fromString(object.unbondingFrequency);
        }
        else {
            message.unbondingFrequency = long_1.default.UZERO;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.connectionId !== undefined && (obj.connectionId = message.connectionId);
        message.bech32prefix !== undefined && (obj.bech32prefix = message.bech32prefix);
        message.hostDenom !== undefined && (obj.hostDenom = message.hostDenom);
        message.ibcDenom !== undefined && (obj.ibcDenom = message.ibcDenom);
        message.creator !== undefined && (obj.creator = message.creator);
        message.transferChannelId !== undefined && (obj.transferChannelId = message.transferChannelId);
        message.unbondingFrequency !== undefined &&
            (obj.unbondingFrequency = (message.unbondingFrequency || long_1.default.UZERO).toString());
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseMsgRegisterHostZone);
        if (object.connectionId !== undefined && object.connectionId !== null) {
            message.connectionId = object.connectionId;
        }
        else {
            message.connectionId = "";
        }
        if (object.bech32prefix !== undefined && object.bech32prefix !== null) {
            message.bech32prefix = object.bech32prefix;
        }
        else {
            message.bech32prefix = "";
        }
        if (object.hostDenom !== undefined && object.hostDenom !== null) {
            message.hostDenom = object.hostDenom;
        }
        else {
            message.hostDenom = "";
        }
        if (object.ibcDenom !== undefined && object.ibcDenom !== null) {
            message.ibcDenom = object.ibcDenom;
        }
        else {
            message.ibcDenom = "";
        }
        if (object.creator !== undefined && object.creator !== null) {
            message.creator = object.creator;
        }
        else {
            message.creator = "";
        }
        if (object.transferChannelId !== undefined && object.transferChannelId !== null) {
            message.transferChannelId = object.transferChannelId;
        }
        else {
            message.transferChannelId = "";
        }
        if (object.unbondingFrequency !== undefined && object.unbondingFrequency !== null) {
            message.unbondingFrequency = object.unbondingFrequency;
        }
        else {
            message.unbondingFrequency = long_1.default.UZERO;
        }
        return message;
    },
};
const baseMsgRegisterHostZoneResponse = {};
exports.MsgRegisterHostZoneResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgRegisterHostZoneResponse);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        const message = Object.assign({}, baseMsgRegisterHostZoneResponse);
        return message;
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = Object.assign({}, baseMsgRegisterHostZoneResponse);
        return message;
    },
};
const baseMsgClaimUndelegatedTokens = { creator: "", hostZoneId: "", epoch: long_1.default.UZERO, sender: "" };
exports.MsgClaimUndelegatedTokens = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.hostZoneId !== "") {
            writer.uint32(18).string(message.hostZoneId);
        }
        if (!message.epoch.isZero()) {
            writer.uint32(24).uint64(message.epoch);
        }
        if (message.sender !== "") {
            writer.uint32(34).string(message.sender);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgClaimUndelegatedTokens);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.creator = reader.string();
                    break;
                case 2:
                    message.hostZoneId = reader.string();
                    break;
                case 3:
                    message.epoch = reader.uint64();
                    break;
                case 4:
                    message.sender = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseMsgClaimUndelegatedTokens);
        if (object.creator !== undefined && object.creator !== null) {
            message.creator = String(object.creator);
        }
        else {
            message.creator = "";
        }
        if (object.hostZoneId !== undefined && object.hostZoneId !== null) {
            message.hostZoneId = String(object.hostZoneId);
        }
        else {
            message.hostZoneId = "";
        }
        if (object.epoch !== undefined && object.epoch !== null) {
            message.epoch = long_1.default.fromString(object.epoch);
        }
        else {
            message.epoch = long_1.default.UZERO;
        }
        if (object.sender !== undefined && object.sender !== null) {
            message.sender = String(object.sender);
        }
        else {
            message.sender = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.creator !== undefined && (obj.creator = message.creator);
        message.hostZoneId !== undefined && (obj.hostZoneId = message.hostZoneId);
        message.epoch !== undefined && (obj.epoch = (message.epoch || long_1.default.UZERO).toString());
        message.sender !== undefined && (obj.sender = message.sender);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseMsgClaimUndelegatedTokens);
        if (object.creator !== undefined && object.creator !== null) {
            message.creator = object.creator;
        }
        else {
            message.creator = "";
        }
        if (object.hostZoneId !== undefined && object.hostZoneId !== null) {
            message.hostZoneId = object.hostZoneId;
        }
        else {
            message.hostZoneId = "";
        }
        if (object.epoch !== undefined && object.epoch !== null) {
            message.epoch = object.epoch;
        }
        else {
            message.epoch = long_1.default.UZERO;
        }
        if (object.sender !== undefined && object.sender !== null) {
            message.sender = object.sender;
        }
        else {
            message.sender = "";
        }
        return message;
    },
};
const baseMsgClaimUndelegatedTokensResponse = {};
exports.MsgClaimUndelegatedTokensResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgClaimUndelegatedTokensResponse);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        const message = Object.assign({}, baseMsgClaimUndelegatedTokensResponse);
        return message;
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = Object.assign({}, baseMsgClaimUndelegatedTokensResponse);
        return message;
    },
};
const baseMsgRebalanceValidators = { creator: "", hostZone: "", numRebalance: long_1.default.UZERO };
exports.MsgRebalanceValidators = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.hostZone !== "") {
            writer.uint32(18).string(message.hostZone);
        }
        if (!message.numRebalance.isZero()) {
            writer.uint32(24).uint64(message.numRebalance);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgRebalanceValidators);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.creator = reader.string();
                    break;
                case 2:
                    message.hostZone = reader.string();
                    break;
                case 3:
                    message.numRebalance = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseMsgRebalanceValidators);
        if (object.creator !== undefined && object.creator !== null) {
            message.creator = String(object.creator);
        }
        else {
            message.creator = "";
        }
        if (object.hostZone !== undefined && object.hostZone !== null) {
            message.hostZone = String(object.hostZone);
        }
        else {
            message.hostZone = "";
        }
        if (object.numRebalance !== undefined && object.numRebalance !== null) {
            message.numRebalance = long_1.default.fromString(object.numRebalance);
        }
        else {
            message.numRebalance = long_1.default.UZERO;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.creator !== undefined && (obj.creator = message.creator);
        message.hostZone !== undefined && (obj.hostZone = message.hostZone);
        message.numRebalance !== undefined &&
            (obj.numRebalance = (message.numRebalance || long_1.default.UZERO).toString());
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseMsgRebalanceValidators);
        if (object.creator !== undefined && object.creator !== null) {
            message.creator = object.creator;
        }
        else {
            message.creator = "";
        }
        if (object.hostZone !== undefined && object.hostZone !== null) {
            message.hostZone = object.hostZone;
        }
        else {
            message.hostZone = "";
        }
        if (object.numRebalance !== undefined && object.numRebalance !== null) {
            message.numRebalance = object.numRebalance;
        }
        else {
            message.numRebalance = long_1.default.UZERO;
        }
        return message;
    },
};
const baseMsgRebalanceValidatorsResponse = {};
exports.MsgRebalanceValidatorsResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgRebalanceValidatorsResponse);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        const message = Object.assign({}, baseMsgRebalanceValidatorsResponse);
        return message;
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = Object.assign({}, baseMsgRebalanceValidatorsResponse);
        return message;
    },
};
const baseMsgAddValidator = {
    creator: "",
    hostZone: "",
    name: "",
    address: "",
    commission: long_1.default.UZERO,
    weight: long_1.default.UZERO,
};
exports.MsgAddValidator = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.hostZone !== "") {
            writer.uint32(18).string(message.hostZone);
        }
        if (message.name !== "") {
            writer.uint32(26).string(message.name);
        }
        if (message.address !== "") {
            writer.uint32(34).string(message.address);
        }
        if (!message.commission.isZero()) {
            writer.uint32(40).uint64(message.commission);
        }
        if (!message.weight.isZero()) {
            writer.uint32(48).uint64(message.weight);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgAddValidator);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.creator = reader.string();
                    break;
                case 2:
                    message.hostZone = reader.string();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.address = reader.string();
                    break;
                case 5:
                    message.commission = reader.uint64();
                    break;
                case 6:
                    message.weight = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseMsgAddValidator);
        if (object.creator !== undefined && object.creator !== null) {
            message.creator = String(object.creator);
        }
        else {
            message.creator = "";
        }
        if (object.hostZone !== undefined && object.hostZone !== null) {
            message.hostZone = String(object.hostZone);
        }
        else {
            message.hostZone = "";
        }
        if (object.name !== undefined && object.name !== null) {
            message.name = String(object.name);
        }
        else {
            message.name = "";
        }
        if (object.address !== undefined && object.address !== null) {
            message.address = String(object.address);
        }
        else {
            message.address = "";
        }
        if (object.commission !== undefined && object.commission !== null) {
            message.commission = long_1.default.fromString(object.commission);
        }
        else {
            message.commission = long_1.default.UZERO;
        }
        if (object.weight !== undefined && object.weight !== null) {
            message.weight = long_1.default.fromString(object.weight);
        }
        else {
            message.weight = long_1.default.UZERO;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.creator !== undefined && (obj.creator = message.creator);
        message.hostZone !== undefined && (obj.hostZone = message.hostZone);
        message.name !== undefined && (obj.name = message.name);
        message.address !== undefined && (obj.address = message.address);
        message.commission !== undefined && (obj.commission = (message.commission || long_1.default.UZERO).toString());
        message.weight !== undefined && (obj.weight = (message.weight || long_1.default.UZERO).toString());
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseMsgAddValidator);
        if (object.creator !== undefined && object.creator !== null) {
            message.creator = object.creator;
        }
        else {
            message.creator = "";
        }
        if (object.hostZone !== undefined && object.hostZone !== null) {
            message.hostZone = object.hostZone;
        }
        else {
            message.hostZone = "";
        }
        if (object.name !== undefined && object.name !== null) {
            message.name = object.name;
        }
        else {
            message.name = "";
        }
        if (object.address !== undefined && object.address !== null) {
            message.address = object.address;
        }
        else {
            message.address = "";
        }
        if (object.commission !== undefined && object.commission !== null) {
            message.commission = object.commission;
        }
        else {
            message.commission = long_1.default.UZERO;
        }
        if (object.weight !== undefined && object.weight !== null) {
            message.weight = object.weight;
        }
        else {
            message.weight = long_1.default.UZERO;
        }
        return message;
    },
};
const baseMsgAddValidatorResponse = {};
exports.MsgAddValidatorResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgAddValidatorResponse);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        const message = Object.assign({}, baseMsgAddValidatorResponse);
        return message;
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = Object.assign({}, baseMsgAddValidatorResponse);
        return message;
    },
};
const baseMsgChangeValidatorWeight = { creator: "", hostZone: "", valAddr: "", weight: long_1.default.UZERO };
exports.MsgChangeValidatorWeight = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.hostZone !== "") {
            writer.uint32(18).string(message.hostZone);
        }
        if (message.valAddr !== "") {
            writer.uint32(26).string(message.valAddr);
        }
        if (!message.weight.isZero()) {
            writer.uint32(32).uint64(message.weight);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgChangeValidatorWeight);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.creator = reader.string();
                    break;
                case 2:
                    message.hostZone = reader.string();
                    break;
                case 3:
                    message.valAddr = reader.string();
                    break;
                case 4:
                    message.weight = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseMsgChangeValidatorWeight);
        if (object.creator !== undefined && object.creator !== null) {
            message.creator = String(object.creator);
        }
        else {
            message.creator = "";
        }
        if (object.hostZone !== undefined && object.hostZone !== null) {
            message.hostZone = String(object.hostZone);
        }
        else {
            message.hostZone = "";
        }
        if (object.valAddr !== undefined && object.valAddr !== null) {
            message.valAddr = String(object.valAddr);
        }
        else {
            message.valAddr = "";
        }
        if (object.weight !== undefined && object.weight !== null) {
            message.weight = long_1.default.fromString(object.weight);
        }
        else {
            message.weight = long_1.default.UZERO;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.creator !== undefined && (obj.creator = message.creator);
        message.hostZone !== undefined && (obj.hostZone = message.hostZone);
        message.valAddr !== undefined && (obj.valAddr = message.valAddr);
        message.weight !== undefined && (obj.weight = (message.weight || long_1.default.UZERO).toString());
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseMsgChangeValidatorWeight);
        if (object.creator !== undefined && object.creator !== null) {
            message.creator = object.creator;
        }
        else {
            message.creator = "";
        }
        if (object.hostZone !== undefined && object.hostZone !== null) {
            message.hostZone = object.hostZone;
        }
        else {
            message.hostZone = "";
        }
        if (object.valAddr !== undefined && object.valAddr !== null) {
            message.valAddr = object.valAddr;
        }
        else {
            message.valAddr = "";
        }
        if (object.weight !== undefined && object.weight !== null) {
            message.weight = object.weight;
        }
        else {
            message.weight = long_1.default.UZERO;
        }
        return message;
    },
};
const baseMsgChangeValidatorWeightResponse = {};
exports.MsgChangeValidatorWeightResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgChangeValidatorWeightResponse);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        const message = Object.assign({}, baseMsgChangeValidatorWeightResponse);
        return message;
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = Object.assign({}, baseMsgChangeValidatorWeightResponse);
        return message;
    },
};
const baseMsgDeleteValidator = { creator: "", hostZone: "", valAddr: "" };
exports.MsgDeleteValidator = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.hostZone !== "") {
            writer.uint32(18).string(message.hostZone);
        }
        if (message.valAddr !== "") {
            writer.uint32(26).string(message.valAddr);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgDeleteValidator);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.creator = reader.string();
                    break;
                case 2:
                    message.hostZone = reader.string();
                    break;
                case 3:
                    message.valAddr = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseMsgDeleteValidator);
        if (object.creator !== undefined && object.creator !== null) {
            message.creator = String(object.creator);
        }
        else {
            message.creator = "";
        }
        if (object.hostZone !== undefined && object.hostZone !== null) {
            message.hostZone = String(object.hostZone);
        }
        else {
            message.hostZone = "";
        }
        if (object.valAddr !== undefined && object.valAddr !== null) {
            message.valAddr = String(object.valAddr);
        }
        else {
            message.valAddr = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.creator !== undefined && (obj.creator = message.creator);
        message.hostZone !== undefined && (obj.hostZone = message.hostZone);
        message.valAddr !== undefined && (obj.valAddr = message.valAddr);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseMsgDeleteValidator);
        if (object.creator !== undefined && object.creator !== null) {
            message.creator = object.creator;
        }
        else {
            message.creator = "";
        }
        if (object.hostZone !== undefined && object.hostZone !== null) {
            message.hostZone = object.hostZone;
        }
        else {
            message.hostZone = "";
        }
        if (object.valAddr !== undefined && object.valAddr !== null) {
            message.valAddr = object.valAddr;
        }
        else {
            message.valAddr = "";
        }
        return message;
    },
};
const baseMsgDeleteValidatorResponse = {};
exports.MsgDeleteValidatorResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgDeleteValidatorResponse);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        const message = Object.assign({}, baseMsgDeleteValidatorResponse);
        return message;
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = Object.assign({}, baseMsgDeleteValidatorResponse);
        return message;
    },
};
const baseMsgRestoreInterchainAccount = { creator: "", chainId: "", accountType: 0 };
exports.MsgRestoreInterchainAccount = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.chainId !== "") {
            writer.uint32(18).string(message.chainId);
        }
        if (message.accountType !== 0) {
            writer.uint32(24).int32(message.accountType);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgRestoreInterchainAccount);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.creator = reader.string();
                    break;
                case 2:
                    message.chainId = reader.string();
                    break;
                case 3:
                    message.accountType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseMsgRestoreInterchainAccount);
        if (object.creator !== undefined && object.creator !== null) {
            message.creator = String(object.creator);
        }
        else {
            message.creator = "";
        }
        if (object.chainId !== undefined && object.chainId !== null) {
            message.chainId = String(object.chainId);
        }
        else {
            message.chainId = "";
        }
        if (object.accountType !== undefined && object.accountType !== null) {
            message.accountType = ica_account_1.iCAAccountTypeFromJSON(object.accountType);
        }
        else {
            message.accountType = 0;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.creator !== undefined && (obj.creator = message.creator);
        message.chainId !== undefined && (obj.chainId = message.chainId);
        message.accountType !== undefined && (obj.accountType = ica_account_1.iCAAccountTypeToJSON(message.accountType));
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseMsgRestoreInterchainAccount);
        if (object.creator !== undefined && object.creator !== null) {
            message.creator = object.creator;
        }
        else {
            message.creator = "";
        }
        if (object.chainId !== undefined && object.chainId !== null) {
            message.chainId = object.chainId;
        }
        else {
            message.chainId = "";
        }
        if (object.accountType !== undefined && object.accountType !== null) {
            message.accountType = object.accountType;
        }
        else {
            message.accountType = 0;
        }
        return message;
    },
};
const baseMsgRestoreInterchainAccountResponse = {};
exports.MsgRestoreInterchainAccountResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgRestoreInterchainAccountResponse);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        const message = Object.assign({}, baseMsgRestoreInterchainAccountResponse);
        return message;
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = Object.assign({}, baseMsgRestoreInterchainAccountResponse);
        return message;
    },
};
const baseMsgUpdateValidatorSharesExchRate = { creator: "", chainId: "", valoper: "" };
exports.MsgUpdateValidatorSharesExchRate = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.chainId !== "") {
            writer.uint32(18).string(message.chainId);
        }
        if (message.valoper !== "") {
            writer.uint32(26).string(message.valoper);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgUpdateValidatorSharesExchRate);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.creator = reader.string();
                    break;
                case 2:
                    message.chainId = reader.string();
                    break;
                case 3:
                    message.valoper = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseMsgUpdateValidatorSharesExchRate);
        if (object.creator !== undefined && object.creator !== null) {
            message.creator = String(object.creator);
        }
        else {
            message.creator = "";
        }
        if (object.chainId !== undefined && object.chainId !== null) {
            message.chainId = String(object.chainId);
        }
        else {
            message.chainId = "";
        }
        if (object.valoper !== undefined && object.valoper !== null) {
            message.valoper = String(object.valoper);
        }
        else {
            message.valoper = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.creator !== undefined && (obj.creator = message.creator);
        message.chainId !== undefined && (obj.chainId = message.chainId);
        message.valoper !== undefined && (obj.valoper = message.valoper);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseMsgUpdateValidatorSharesExchRate);
        if (object.creator !== undefined && object.creator !== null) {
            message.creator = object.creator;
        }
        else {
            message.creator = "";
        }
        if (object.chainId !== undefined && object.chainId !== null) {
            message.chainId = object.chainId;
        }
        else {
            message.chainId = "";
        }
        if (object.valoper !== undefined && object.valoper !== null) {
            message.valoper = object.valoper;
        }
        else {
            message.valoper = "";
        }
        return message;
    },
};
const baseMsgUpdateValidatorSharesExchRateResponse = {};
exports.MsgUpdateValidatorSharesExchRateResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgUpdateValidatorSharesExchRateResponse);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        const message = Object.assign({}, baseMsgUpdateValidatorSharesExchRateResponse);
        return message;
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = Object.assign({}, baseMsgUpdateValidatorSharesExchRateResponse);
        return message;
    },
};
class MsgClientImpl {
    constructor(rpc) {
        this.rpc = rpc;
        this.LiquidStake = this.LiquidStake.bind(this);
        this.RedeemStake = this.RedeemStake.bind(this);
        this.RegisterHostZone = this.RegisterHostZone.bind(this);
        this.ClaimUndelegatedTokens = this.ClaimUndelegatedTokens.bind(this);
        this.RebalanceValidators = this.RebalanceValidators.bind(this);
        this.AddValidator = this.AddValidator.bind(this);
        this.ChangeValidatorWeight = this.ChangeValidatorWeight.bind(this);
        this.DeleteValidator = this.DeleteValidator.bind(this);
        this.RestoreInterchainAccount = this.RestoreInterchainAccount.bind(this);
        this.UpdateValidatorSharesExchRate = this.UpdateValidatorSharesExchRate.bind(this);
        this.ClearBalance = this.ClearBalance.bind(this);
    }
    LiquidStake(request, metadata) {
        return this.rpc.unary(exports.MsgLiquidStakeDesc, exports.MsgLiquidStake.fromPartial(request), metadata);
    }
    RedeemStake(request, metadata) {
        return this.rpc.unary(exports.MsgRedeemStakeDesc, exports.MsgRedeemStake.fromPartial(request), metadata);
    }
    RegisterHostZone(request, metadata) {
        return this.rpc.unary(exports.MsgRegisterHostZoneDesc, exports.MsgRegisterHostZone.fromPartial(request), metadata);
    }
    ClaimUndelegatedTokens(request, metadata) {
        return this.rpc.unary(exports.MsgClaimUndelegatedTokensDesc, exports.MsgClaimUndelegatedTokens.fromPartial(request), metadata);
    }
    RebalanceValidators(request, metadata) {
        return this.rpc.unary(exports.MsgRebalanceValidatorsDesc, exports.MsgRebalanceValidators.fromPartial(request), metadata);
    }
    AddValidator(request, metadata) {
        return this.rpc.unary(exports.MsgAddValidatorDesc, exports.MsgAddValidator.fromPartial(request), metadata);
    }
    ChangeValidatorWeight(request, metadata) {
        return this.rpc.unary(exports.MsgChangeValidatorWeightDesc, exports.MsgChangeValidatorWeight.fromPartial(request), metadata);
    }
    DeleteValidator(request, metadata) {
        return this.rpc.unary(exports.MsgDeleteValidatorDesc, exports.MsgDeleteValidator.fromPartial(request), metadata);
    }
    RestoreInterchainAccount(request, metadata) {
        return this.rpc.unary(exports.MsgRestoreInterchainAccountDesc, exports.MsgRestoreInterchainAccount.fromPartial(request), metadata);
    }
    UpdateValidatorSharesExchRate(request, metadata) {
        return this.rpc.unary(exports.MsgUpdateValidatorSharesExchRateDesc, exports.MsgUpdateValidatorSharesExchRate.fromPartial(request), metadata);
    }
    ClearBalance(request, metadata) {
        return this.rpc.unary(exports.MsgClearBalanceDesc, exports.MsgClearBalance.fromPartial(request), metadata);
    }
}
exports.MsgClientImpl = MsgClientImpl;
exports.MsgDesc = {
    serviceName: "stride.stakeibc.Msg",
};
exports.MsgLiquidStakeDesc = {
    methodName: "LiquidStake",
    service: exports.MsgDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.MsgLiquidStake.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            return Object.assign(Object.assign({}, exports.MsgLiquidStakeResponse.decode(data)), { toObject() {
                    return this;
                } });
        },
    },
};
exports.MsgRedeemStakeDesc = {
    methodName: "RedeemStake",
    service: exports.MsgDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.MsgRedeemStake.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            return Object.assign(Object.assign({}, exports.MsgRedeemStakeResponse.decode(data)), { toObject() {
                    return this;
                } });
        },
    },
};
exports.MsgRegisterHostZoneDesc = {
    methodName: "RegisterHostZone",
    service: exports.MsgDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.MsgRegisterHostZone.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            return Object.assign(Object.assign({}, exports.MsgRegisterHostZoneResponse.decode(data)), { toObject() {
                    return this;
                } });
        },
    },
};
exports.MsgClaimUndelegatedTokensDesc = {
    methodName: "ClaimUndelegatedTokens",
    service: exports.MsgDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.MsgClaimUndelegatedTokens.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            return Object.assign(Object.assign({}, exports.MsgClaimUndelegatedTokensResponse.decode(data)), { toObject() {
                    return this;
                } });
        },
    },
};
exports.MsgRebalanceValidatorsDesc = {
    methodName: "RebalanceValidators",
    service: exports.MsgDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.MsgRebalanceValidators.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            return Object.assign(Object.assign({}, exports.MsgRebalanceValidatorsResponse.decode(data)), { toObject() {
                    return this;
                } });
        },
    },
};
exports.MsgAddValidatorDesc = {
    methodName: "AddValidator",
    service: exports.MsgDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.MsgAddValidator.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            return Object.assign(Object.assign({}, exports.MsgAddValidatorResponse.decode(data)), { toObject() {
                    return this;
                } });
        },
    },
};
exports.MsgChangeValidatorWeightDesc = {
    methodName: "ChangeValidatorWeight",
    service: exports.MsgDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.MsgChangeValidatorWeight.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            return Object.assign(Object.assign({}, exports.MsgChangeValidatorWeightResponse.decode(data)), { toObject() {
                    return this;
                } });
        },
    },
};
exports.MsgDeleteValidatorDesc = {
    methodName: "DeleteValidator",
    service: exports.MsgDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.MsgDeleteValidator.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            return Object.assign(Object.assign({}, exports.MsgDeleteValidatorResponse.decode(data)), { toObject() {
                    return this;
                } });
        },
    },
};
exports.MsgRestoreInterchainAccountDesc = {
    methodName: "RestoreInterchainAccount",
    service: exports.MsgDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.MsgRestoreInterchainAccount.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            return Object.assign(Object.assign({}, exports.MsgRestoreInterchainAccountResponse.decode(data)), { toObject() {
                    return this;
                } });
        },
    },
};
exports.MsgUpdateValidatorSharesExchRateDesc = {
    methodName: "UpdateValidatorSharesExchRate",
    service: exports.MsgDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.MsgUpdateValidatorSharesExchRate.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            return Object.assign(Object.assign({}, exports.MsgUpdateValidatorSharesExchRateResponse.decode(data)), { toObject() {
                    return this;
                } });
        },
    },
};
exports.MsgClearBalanceDesc = {
    methodName: "ClearBalance",
    service: exports.MsgDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.MsgClearBalance.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            return Object.assign(Object.assign({}, exports.MsgClearBalanceResponse.decode(data)), { toObject() {
                    return this;
                } });
        },
    },
};
class GrpcWebImpl {
    constructor(host, options) {
        this.host = host;
        this.options = options;
    }
    unary(methodDesc, _request, metadata) {
        var _a;
        const request = Object.assign(Object.assign({}, _request), methodDesc.requestType);
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new browser_headers_1.BrowserHeaders(Object.assign(Object.assign({}, (_a = this.options) === null || _a === void 0 ? void 0 : _a.metadata.headersMap), metadata === null || metadata === void 0 ? void 0 : metadata.headersMap))
            : metadata || this.options.metadata;
        return new Promise((resolve, reject) => {
            grpc_web_1.grpc.unary(methodDesc, {
                request,
                host: this.host,
                metadata: maybeCombinedMetadata,
                transport: this.options.transport,
                debug: this.options.debug,
                onEnd: function (response) {
                    if (response.status === grpc_web_1.grpc.Code.OK) {
                        resolve(response.message);
                    }
                    else {
                        const err = new Error(response.statusMessage);
                        err.code = response.status;
                        err.metadata = response.trailers;
                        reject(err);
                    }
                },
            });
        });
    }
}
exports.GrpcWebImpl = GrpcWebImpl;
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
//# sourceMappingURL=tx.js.map